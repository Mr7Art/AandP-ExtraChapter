Смысл дополнительных глав в том, чтобы раскрыть некоторые темы, которые находятся рядом с основным курсом Алгоритмизации и программировании. 

# Лекция Р0: Получение справочной информации

Работая со средой программирования или любой другой программой будут возникать вопросы.
Главная задача - это уметь находить правильные ответы на свои вопросы.

Способы нахождения ответов на вопросы:
1. Спросить знающего человека - эксперта;
2. Воспользоваться книгами или учебниками;
3. Воспользоваться электронной справочной системой;

*Книга*: Алгоритмы. Построение и анализ. Авторы: Томас Кормен, Чарльз  Лейзерсон, Рональд Ривест

Электронная справочная система в контексте языка C#:
1. Контекстная справка - чтобы вызвать контекстную справку, необходимо щелкнуть по интересующему стандартному оператору или функции и нажать кнопку: "F1" (откроется браузер на странице: https://learn.microsoft.com/ с необходимой информацией). Работает только с базовыми библиотеками;
2. Обозреватель объектов - чтобы вызвать обозреватель объектов, необходимо нажать нажать кнопку: "F2" (или найти в меню: "Вид"). Лучше сделать фильтр по пространству имен. Обозреватель объектов показывает в иерархической структуре, пространства имен и все что в него вложено. Тактика работы с обозревателем имен - это когда примерно знаешь, какой класс нужен и в нем можешь найти необходимые методы (знак подсказка: фиолетовые кубики), свойства (знак подсказка: гаечный ключ), события (знак подсказка желтая молния);
3. Работа с системой на сайте: https://learn.microsoft.com/ На сайте есть не только справочники по языкам программирования, но и разная полезная информация. Есть раздел на сайте с репозиториями проектов для практического обучения;
4. Обратиться к AI ассистенту. У способа есть плюсы и минусы. Минусы: AI дает решение, но не дает объяснение;

# Лекция Р1: Жизненный цикл ПО

Жизненный цикл ПО (ЖЦПО) - период от рождения программы до ее забвения.

*Этапы разработки программного продукта*:
1. Постановка задачи. Оценка осуществимости;
Конечный этап этого шага, это принятие решения: будем ли реализовывать проект или нет.
Чтобы оценить возможно ли справиться с задачей или нет необходимо пройти несколько шагов:
* сбор информации о задаче (как компания работает, с чем работает, с какими данными). Данный этап выполняется в виде интервью (устных или письменных), серии встреч, мозговой штурм и т.д.;
* формулировка условия задачи. Никакая задача не может быть решена абстрактно, всегда есть некие ограничения.;
* определение конечных целей решения задачи;
* определение формы выдачи результатов;
* описание данных;
* *дополнение*: время, сроки, стоимость;

Если решение принято, то составляется документ: Техническое задание - официальный документ.
Без технического задания, начинать работу бессмысленно.
Выполнение этого этапа тоже должно оплачиваться, так как этот этап занимает не один день.

2. Анализ и исследование задачи, модели:
	- разработка математической модели;
	- разработка структур данных;
	- архитектура информационной системы;

Модель - это попытка в виртуальной среде представить реально существующие объекты или явления. Всегда когда модель строиться, всегда происходит упрощение. Любая модель проще, чем реальность, так как все детали не нужны.
Конечный этап этого шага - это составлено понимание о будущей системе и предметной области с которой работаем, но нет главного ответа на вопрос: "Что делать?" и "Как делать?"

3. Разработка алгоритмов:
	* выбор методов и подходов;
	* проектирование алгоритмов. Скорее всего алгоритм будет не один, необходимо выбрать оптимальные алгоритмы;

4. Программирование (кодирование):
	* выбор стека технологий (языка программирования и т.п.);
	* уточнение способа организации данных;
	* запись алгоритмов на языке программирования;

На данном этапе, программист подучает всю техническую документацию и должен воспроизвести все в программном коде. Шаг в сторону от задуманного не приветствуется (инициатива не приветствуется).
Возможности творческой реализации для программиста заключаются в отражении (реализации) концепции (алгоритмов) описанной в технической документации с помощью различных технологий и различных вариантов решения поставленных задач.
Хорошую математическую модель, можно испортить плохой реализацией и наоборот улучшить сделать более эффективной и интересной.
Конечный этап данного шага - это окончание этапа программирования (достижение промежуточного результата)

5. Тестирование и отладка:
	* выбор тестов и методов тестирования;
	* синтаксическая отладка;
	* отладка семантики и логической структуры;
	* тестовые расчеты и анализ результатов тестирования; 

Задача данного шага - выявить логические ошибки, которые приводят к некорректной работе программы и указать, в чем состоят ошибки, чтобы программист исправил ошибки.
На данном этапе, используются различные методы тестирования: нагрузочное тестирование, тестирование пользовательских интерфейсов и т.д.

Важная задача - это оценить количество ошибок в том или ином проекте для планирования работы сотрудников и т.д.
Как оценить количество ошибок в проекте: нужно сделать специально ошибки в коде, отдать тестировщикам и посмотреть, сколько ошибок они найдут. Если нашли 50 ошибок и все 50 ошибок нами созданы - это означает, что настоящих ошибок мало или просто нет. А если тестировщики нашли 50 ошибок и из них часть ошибок сделана не специально, то это означает, что в программе много ошибок.

6. Анализ результатов решения задач и уточнение, в случае необходимости, математической модели и возможный возврат с повторным выполнением шагов 2-5.

Чем к более раннему этапу осуществляется возврат, тем больше этапов необходимо будет провести заново.

7. Сопровождение программы:
	- составление документации к решенной задаче, к математической модели, к алгоритму, к программе, к набору тестов, к использованию;
	- подготовка к распространению, развертыванию программы (Deployment). Если необходимо, то закупка оборудования (сервер и т.д.), создание базы пользователей, распределение ролей пользователей и т.д.;
	- поддержка пользователей;
	- совершенствование программы;


## Жизненный цикл программного продукта

Разработка сложных информационных систем (продуктов), достаточно сложный процесс в зависимости от многих причин:
1. В разработке информационной системы задействовано довольно большое количество сотрудников: аналитики, владельцы продукта, специалисты по безопасности, специалисты по анализу данных, тестировщики, служба технической поддержки, служба по внедрению, служба по обучению пользователей;
2. Информационный продукт непростой. Это не 50 строчек кода и даже не 1000 строчек кода, это намного больше, причем современные информационные системы - это системы многокомпонентные, и если каждый из компонентов работает, то не факт, что они будут работать вместе.
3. Удовлетворение нужд заказчика. Система может быть сделана замечательно, но может прийти заказчик и сказать, что ему что-то не нравится.

В связи с указанными причинами, сроки разработки зачастую довольно большие, но также все зависит от проекта и от возможностей самой компании.
Поэтому, и появляется понятие жизненного цикла ПО, так как продукт постоянно развивается.

**Модель жизненного цикла информационной системы (Модель ЖЦ ИС)** - это структура, определяющая последовательность процессов, действий и задач, выполняемых на протяжении ЖЦ ИС, а также взаимосвязи между ними.

Оценка рисков продолжения работ

## Виды моделей жизненного цикла информационных систем:

### 1. Водопадная (каскадная) модель (Waterfall)

![[Pasted image 20251114122808.png]]

Специфика модели:
- Разбиение разработки на этапы;
- Последовательная организация работ;
- Выпуск полного комплекта документов при переходе на следующий этап;

*Примечание*: Возвращение на предыдущий этап не предусматривается, циклы возможны внутри самих этапов.

*Недостатки модели*:
- существенная задержка получения результатов;
- необходимость возврата на предыдущие этапы;
- сложность распараллеливания работ по проекту;
- информационная перенасыщенность каждого этапа;
- сложность управления проектом;
- высокий уровень риска и ненадежности инвестиций (каждая следующая команда зависит от выполнения предыдущего этапа);

Водопадная модель подходит для относительно простых задач: шаблонные, типовые задачи.

### 2. Спиральная модель

![[Pasted image 20251114124815.png]]

*Специфика модели*:
- Итерационный процесс работ;
- Активное использование прототипов (промежуточная версия, которая может не включать некоторые компоненты);
- Система версий;
- Постепенная конкретизация;
- Постепенная интеграция компонентов в сложных системах. Необходимо учитывать, что разработку, тестирование и апробацию одного компонента можно делать без остальных компонентов. Отсутствие иных компонентов не должно мешать процессу;
- Снижение уровня рисков;
- Упрощение внесения тактических изменений;

*Недостатки модели*:
- Определение момента перехода на следующий этап. Сложность временной оценки;
- Бесконечное совершенствование (бесконечную спираль улучшений, когда улучшения следуют одно за другим, и это отодвигает сроки финальной сдачи);
- Согласование итогов работы, согласование исходного задания, взаимодействие между разными отделами (Различные отделы могут находится на противоположных концах спирали);

### 3. Agile модель

Agile можно сравнить с философией или даже можно назвать это религией в сфере IT. Действительно ли модель Agile так хороша, вопрос не однозначный.

Модель Agile хорошо работает в относительно небольших коллективах, с новыми проектами, инновационными проектами, с проектами исследовательскими. 
Идеальная ситуация, когда модель Agile можно применять - это всевозможные стартапы, потому, что как раз для стартапа характерен небольшой коллектив (до 30 человек), неоднозначность в способах решения, так как стартап ежедневно сталкивается со сложностями, которые приходятся решать.

В больших корпорациях (Яндексе, Сбербанке, Тинькофф), вполне может быть то же самое, когда приходит команда к руководителю, предлагает новый проект и если получает одобрение, то тогда пытается разработать и запустить свой продукт внутри большой корпорации.

*Методология Agile*:
![[Pasted image 20251206155403.png]]

*Спринты (спрайты) в Agile*:
![[Pasted image 20251206155732.png]]

*Agile-методология*:
- Agile software development (гибкая методология разработки);
- Agile-методы - обобщающий термин для целого ряда подходов и практик, основанных на ценностях Манифеста гибкой разработки программного обеспечения и 12 принципах, основные из них:
	- Работа в небольших группах. Все друг друга знают лично и знают свои возможности;
	- Серия коротких циклов (циклы реализации). Недельные или двухнедельные циклы. Устраняет риски долгой обратной связи;
	- Уменьшение объема письменной документации. Общение происходит на вербальном уровне (устно) показываете коллегам раз в неделю или два раза в неделю что получилось сделать и получаете обратную связь, критику, а также обсуждаете и принимаете решение, как двигаться дальше;
	- Люди и взаимодействие важнее процессов и инструментов;
	- Работающий продукт важнее исчерпывающей документации;
	- Сотрудничество с заказчиком важнее согласования условий контракта. Необходимо быть постоянно на связи с заказчиком, чтобы не оказалось, что все что сделано - это не нужно заказчику;
	- Готовность к изменениям важнее следования первоначальному плану;
	- Удовлетворение клиента за счет ранней бесперебойной поставки ценного программного обеспечения. Понять реальные плюсы и минусы продукта, можно только при реальной эксплуатации, поэтому, если есть минимально готовый продукт, то его нужно отдать заказчику;
	- Приветствие изменения требований даже в конце разработки (это может повысить конкурентоспособность конечного продукта);
	- Частая поставка рабочего программного обеспечения (каждый месяц или неделю или чаще);
	- Тесное ежедневное общение заказчика с разработчиками на протяжении всего проекта. Иногда общение ради общения превалирует, так как что может произойти за один день, если вчера обсуждалась задача;
	- Проектом занимаются мотивированные личности, которые обеспечены нужными условиями работы, поддержкой и доверием;
	- Рекомендованный метод передачи информации - личный разговор (лицом к лицу);
	- Работающее программное обеспечение - лучший измеритель прогресса;
	- Спонсоры, разработчики и пользователи должны иметь возможность поддерживать постоянный темп на неопределенный срок;
	- Постоянное внимание к улучшению технического мастерства и удобному дизайну;
	- Простота - искусство не делать лишней работы;
	- Лучшие технологические требования, дизайн и архитектура получаются у самоорганизованной команды;
	- Постоянная адаптация к изменяющимся обстоятельствам. Команда должна систематически анализировать возможные способы улучшения эффективности и, соответственно, корректировать стиль своей работы.

Если внимательно посмотреть на тезисы в манифесте Agile, то уже становится ясно, что они не такие однозначные.

Agile методология имеет как преимущества, так и недостатки. Agile подход - это скорее неоднозначные исследовательские проекты, которые имеют довольно высокие риски при создании, при разработке, где на стартовом этапе до конца непонятен план и алгоритмы, где имеется только общее представление о будущей архитектуре, но хотим уточнять это в процессе и где есть небольшая управляемая команда. Для описанных ситуаций Agile методология подходит идеально.


## Другие схемы разработки программного продукта


![[Pasted image 20251206160612.png]]

1. Концептуальный дизайн строится на базе понимания будущего продукта заказчиками. Понимание формулируется на уровне обычного, общедоступного языка, без технических подробностей, только на том уровне, на котором понимает заказчик. Концептуальный дизайн формулируется в терминах, понятных и заказчику и разработчику

В данном пункте необходимо прийти к общему пониманию по следующим пунктам:
- Что мы хотим?
- Как это будет работать на уровне описания процессов;
- На уровне описания ролей;
- На уровне описания use case diagram (т.е. последовательности действий и прохождения); 
- На уровне описания данных, с которыми система будет работать;
- Что мы ждем от системы?
- Как мы видим ее в идеальном формате?

После того, как разработчик и заказчик пришли к общему понимаю по вышеуказанным вопросам, то необходимо составить документ и , подписать его с двух сторон. Так как именно по нему будет необходимо  отчитываться в будущем.

2. Логический дизайн - это уже со всеми IT подробностями, но на уровне схем, без физического написания кода без физического создания каких-то таблиц баз данных и так далее. Это логика: на уровне алгоритмов, на уровне моделей, на уровне архитектуры, на уровне всей системы в целом.

3. Физический дизайн - это самый нижний уровень, до конкретного кода, до конкретных функций, классов.

## Единая система программной документации

Документация связывает различные отделы между собой.

***Виды документов***:
- Техническое задание (В документе говорится, что заказчик хочет получить);
- Программа и методика испытаний (В документе описывается, какой должна быть программа, как ее тестировать и какие показатели тестов закладываются. Т.е. быстродействие было не хуже, чем вот такое-то. Надежность должна быть не хуже, чем такая-то. Документ разрабатывается, когда программы еще нет, но он составляется после всей подготовительной работы. При разработке программы, можно сверяться с данным документом для определения корректности работы программы);
- Руководство системного программиста (Документ, который рассказывает, как систему разворачивать, настраивать. Документ создается, когда программа готова);
- Руководство пользователя (Документ создается, когда программа готова);
- Руководство программиста SDK (Software Developer Kit) и API (Application Program Interface) - это документация для внешних разработчиков, которая помогает понять и использовать чужие  наработки;

API (Application Program Interface) - перечень декларации функций или классов, или констант, или чего-то еще и их спецификации с кратким описанием, что они делают, похоже на справку.


Спецификации ПО (в схемах):
- Структурная модель - схематичное представление структуры информационной системы. Из каких частей состоит система и как эти части между собой связаны;
![[Pasted image 20251206170400.png]]

- Функциональная, поведенческая модель - взаимодействие системы или ее отдельных компонент (возможно) внешнего окружения. Акцент на взаимодействии компонентов, то есть как они взаимодействуют между собой;
![[Pasted image 20251206170522.png]]

- Модель данных - структуры для представления данных;
![[Pasted image 20251206170952.png]]

- Объектная модель -представление классов в терминах ООП. Если классов много и если они связаны между собой (наследование и т.д.), то тогда схема классов очень полезна;
![[Pasted image 20251206170649.png]]

При создании схем используют следующие стандарты: 
- UML (Unified Modeling Language) - универсальный язык моделирования;
- IDEF (Integrated DEFinition);

Visual Studio умеет формировать схему классов автоматически, но если программа готова.

# Лекция: Поиск ошибок и инструменты отладки

При написании программы, так или иначе возникают ошибки и это нормально, когда ошибки возникают. Необходимо уметь ошибки фиксировать, находить их причину и исправлять их.

*Можно выделить три вида ошибок*:
1. Ошибки синтаксические. 
	Связаны с неправильным написанием операторов, переменной, функции и т.д. Без исправления синтаксических ошибок, программу просто не откомпилировать. На данный момент, в средах программирования такие ошибки подсвечиваются и чаще всего предлагаются варианты их исправления;
2. Ошибки времени выполнения или exception. 
	Данные ошибки не связаны с синтаксисом, программа нормально написана, нормально запускается, компилируется и начинает работать, но в процессе работы возникают какие-то форс-мажорные обстоятельства.
	Чаще всего такого рода ошибки называются еще runtime error, то есть ошибки времени выполнения, или exception исключительной ситуации.
	Обычно, данные ошибки возникают из-за внешней среды (некорректный ввод пользователем данных и т.д.).
3. Ошибки логические.
	Самый сложный вид ошибок, так как:
		 Во-первых, непонятно, есть логическая ошибка или нет, и разработчик так и не может определить наличие этой ошибки до тех пор, пока уже пользователи ему на это не укажут. Одна из причин, почему такое происходит, это не стабильное возникновение ошибки;
		 Во-вторых, никто не скажет, что ошибка имеет место быть. 
		 В-третьих, еще есть менее очевидные логические ошибки, к примеру, результат правильный, но, память не освобождается (утечка памяти).
	Для поиска и устранения логических ошибок, обычно делают систему тестов.

Среди средств обнаружения логических ошибок можно использовать инструменты самой среды программирования.
### Инструменты отладки

Первое, что часто использует программист, это пошаговое выполнение кода.
Пошаговое исполнение кода может быть выполнено с помощью кнопок отладки на панели инструментов.

На панели инструментов есть три кнопки отладки:
- Шаг с заходом (step into) - заходит в выполняемую функцию;
- Шаг с обходом (step over) - не заходит в выполняемую функцию;
- Шаг с выходом (step out) - все команды, которые ниже курсора выполнятся и случится выход из функции;

*Примечание*: Кнопки отладки можно также найти в меню: "Откладка" и еще можно использовать комбинации клавиш.

В процессе отладки бывает полезным это инспектирование переменных, то есть мониторинг чему они равны и как они меняются.

Провести инспектирование переменных можно только в режиме отладки программы.

Способы просмотра значений переменных при инспектировании:
1. Просто навести мышку на переменную;
2. Использование окна: "Локальные значения". В данном окне показываются все переменные, которые видны в текущем контексте и их изменения.
3. Использование окна: "Контрольные значения" (watch). В данном окне можно добавить какую угодно переменную и наблюдать за ней. Оно удобно тем, если необходимо наблюдать за какой-то конкретной переменной или переменными. В окно можно самому записать значения, правда не любые, а только: переменные, константы и знаки операции, логические выражения (res > 0).

*Примечание*: Через меню: "Откладка", можно открыть до 4-х окон: "Контрольные значения".

**Точка остановки (breakpoint)** - позволяет остановить программу в определенном месте.

Для того, чтобы поставить точку остановки в Visual Studio, необходимо нажать на серой области слева от   точку очень легко надо вот на этой серой области слева от основного окна (окно, где написан сам код).
Точку остановки можно поставить там где нет пустых строк, комментариев и есть операторы, также можно поставить несколько точек остановки.

У точки остановки есть параметры и можно поставить условия, когда она выполняется.

Иногда бывает удобно не использовать инструменты отладки, а использовать обычные средства которые тоже могут быть применимы в процессе отладки.

В инструментах отладки много возможностей, также можно смотреть память, регистры,  проверять стек, утечку памяти, и так далее.


# Лекция Р2: Платформа .Net (dot Net)

C# - относительно молодой язык программирования, появился как логическое развитие языка C++.

Раньше, когда среды разработки только зарождались, не факт, что написанный код в одной среде, успешно будет скомпилирован в другой. Для успешной компиляции требовалось строгое соблюдение стандартов языка программирования и сведение к минимуму использование особенностей той или иной среды разработки.

Основа C# - это C++, есть схожие моменты в синтаксисе и некоторых приемах, но в C# были реализованы многие моменты, за которые ругали C++, в частности один из главных моментов: типобезопасный язык и язык безопасный к использованию памяти.

Сейчас, ситуация уже обратная, C++ стал догоняющим языком программирования, так как новые особенности добавляются с существенной задержкой и во многом повторяют то, что уже реализовано в C#. К примеру, в C# можно динамически управлять  массивами (можно легко создать массив и в процессе работы изменить его размер), а в C++ этого достичь было не так просто, а возможность динамически управлять массивами появилась совсем недавно. Тоже касается и строк, до некоторых пор в C++ строка была одномерным массивом, объявляемым самостоятельно с типом: "char" и с данным массивом приходилось работать, в то время как в C# - это отдельный тип: "string" и в переменную типа: "string"  можно записать текст и объединить его с другим текстом, применить функцию строковую и т.д.
Неопытный программист работая со стоками даже может не подозревать, что строка - это одномерный массив, так как в C# ничего это не выдает, а в C++ - это сложнее.
Сейчас C# больше похож на Java, чем на своего родителя C++ в идеологическом аспекте.

C# является объектно-ориентированным языком, который относится к категории RAD (rapid application development - быстрая разработка приложений)

Революционность C# состоит не только в возможностях самого языка, а еще и во всей инфраструктуре, которая его окружает.

В C# - это окружение называют: ".Net".

.Net - это платформа (где-то называется Framework) куда входит набор библиотек и единообразный поход к некоторым техническим операциям (например, к операции компиляции кода).

Кроме того, к ".Net" (примечание: dot Net) относят те компоненты, которые туда входят. К примеру, сборщик мусора - является универсальным компонентов для всех приложений ".Net" и не важно на каком языке это написано.

Идеология: ".Net" является открытой и любой разработчик или компания могут придумать свой язык, которой этой идеологии будут удовлетворять. К примеру, в продуктах компании: AutoCad используются языки, которые основаны на идеологии: ".Net".

Платформа: ".Net" ни с C# ни с Visual Studio не связана, ее можно установить самостоятельно. Если на компьютере развернута система: Windows, то платформа: ".Net" устанавливается вместе в пакете и не требует дополнительных действий.

На других операционных системах: Unix, MacOs, есть свои версии платформы: ".Net", которые позволяют запускать программный код, который написан на совместимых языках и на этих операционных системах.

## Ключевые особенности языка C\#

* **Объектно-ориентированный язык**
Вначале появилась парадигма: объектно-ориентированного подхода и языки программирования, потом программисты это пытались осознать, понять и принять, затем писали код, а потом проекты стали большие и мощные, что объектов и классов не совсем удовлетворяли запросам, потом появились: "Template" (шаблоны).
Понятие ООП (объектно-ориентированного программирования) - это не что-то фиксированное. В одном языке, который тоже объектно-ориентированный может быть что-то реализовано, а в другом языке этого может и не быть. Например, множественное наследование в C# отсутствует, а в другом языке это может быть, но в C# это реализуется с помощью других инструментов.

* **Единая система типов в ".Net"**
Платформа: ".Net" - это самостоятельная инженерная единица и язык разработки может быть совместим с этой платформой или не быть совместим.
C# не единственный язык, который опирается на платформу: ".Net" еще есть VB .Net,  F# - это означает, что они применяют одни и те же приемы и технологии в частности единую систему типов.
Нет отдельных библиотек для C#, VB .Net, F# - на низком уровне библиотека типов для них одинаковая, это улучшает совместимость и позволяет запускать функции без особых проблем.
Стоит сказать, что это работает одинаково для всех языков, совместимых с платформой: ".Net".

* **Определяемые пользователем ссылочные типы и типы по значению**

* **Значение null**

* **Автоматическая сборка мусора**
С простыми переменными типа: int, short - это неактуально, так как там нет такой задачи. Это актуально для динамического управления памятью, когда работают с объектами.
В чем принципиальная разница объектов, объект можно в любой момент создать и в любой момент уничтожить, а переменная с типом: "int" работает не так, она сама создается когда мы заходим в функцию и сама уничтожается, когда функция завершает работу, а переменную объектную можно в любой момент создать и уничтожить и если автоматической сборки мусора нет, то это возлагается на программиста и если он забыл уничтожить переменную, то память остается занятой и это может приводить к утечкам памяти.

* **Структурированный и расширяемый подход к обработке исключений** 

* **Лямбда-выражения - функциональных подход**
Принципиальное изменение за несколько лет. Это функциональный подход. Сейчас в C# элементы функционального подхода можно использовать.

* **LINKQ - общий подход для работы с данными**
Позволяет не заботиться о том, как физически организован источник данных (реляционная БД или нереляционная БД, какая-то еще), мы можем просто вытащить данные и обрабатывать их через данный механизм.

* **Асинхронные операции**
Распараллеливание алгоритмов и использование асинхронного подхода


## Особенности платформы .Net (dot Net)

* ".Net" (dot Net) - это свободная платформа (is a free) с открытым исходным кодом (open-source) для кросс-платформенной разработки (cross-platform development platform: Linux, MacOS, Windows);

**"is a free"** - означает, что платформа распространяется бесплатно. Продукты, которые созданы при помощи платформы, могут быть использованы по усмотрению разработчиков, в том числе и с целью коммерческой выгоды;
**"open-source"** - означает, что открытый исходный код доступен для анализа и предложения по улучшению исходного кода принимаются разработчиками платформы: ".Net" и рассматриваются и могут быть включены в последующие релизы платформы;
**"cross-platform"** - продукты создаваемые при помощи платформы: ".Net", можно запускать на операционных системах: Linux, MacOS, Windows.

* **Платформа** - это совокупность языков программирования, библиотек и сервисов;

Каждый отдельный компонент большой ценности не представляет. К примеру, язык программирования C# нельзя представить без основополагающих библиотек или библиотеки невозможно представить без соответствующих сервисов (управление памятью и сборка мусора). По отдельности это не работает, ценность заключается именно в совокупности.
Библиотеки с классами и функциями созданы с тем расчетом, что действия будут кем-то выполняться (сервисом).

* Область применения: предназначена для разработки разных типов приложений: Mobile, Desktop, Web, Cloud, Microservices.

Среда (платформа): ".Net" предназначена для масштабных приложений верхнего уровня (в основном) для различного рода автоматизации в разном форм-факторе.

*Схема платформы: ".Net"*:
![[Pasted image 20251222231557.png]]

*Комментарии к схеме платформы: ".Net"*:
- Основных языков для три: C#, VB, F# плюс любой автор или организация могут придумать свой язык, который будет совместим с платформой: ".Net"
- **Common Language Specification (CLS)** - это свод правил, которым должны подчиняться языки, т.е. обязательная основа, которая в каждом языке должна быть. Какие могут быть особенности в самом языке в CLS не оговаривается, в C# свои особенности в F# свои, но основа задается CLS. CLS - это не документация по языку, это документация о том, что язык должен реализовывать.
- Средства с помощью которых можно реализовывать определенный форм-фактор или стек технологий, например:
	- С помощью ASP.Net - можно разрабатывать web-приложения;
	- С помощью WPF (Windows Presentation Foundation) - фреймворк Microsoft для создания современных клиентских приложений Windows, можно разрабатывать оконные приложения;
	- С помощью MAUI - можно разрабатывать универсальные кросс-платформенные приложения с оконным интерфейсом;
	- и др.

У некоторых разработчиков есть определенный скепсис по поводу: MAUI и похожих разработок, которые считают, что невозможно реализовать универсальный фреймворк, который предназначен для разработки приложения под любую определенную систему, так как в каждой операционной системе есть свои особенности.
Одно дело, если разрабатывается web-приложение, оно по настоящему кросс-платформенное, но с некоторыми оговорками в связи с особенностями, так как web-приложение работает в контейнере, оно является контейнером в некоторой оболочке (браузере), т.е. код написанный на HTML и CSS обрабатывается не операционной системой, а браузером и он переводит команды которые есть в коде в то, что ожидает операционная система за счет чего и создается кросс-платформенность.
Каждая технология - это набор библиотек. Для того, чтобы создать приложения с помощью WPF, нужно подключить библиотеку и использовать классы, которые там реализованы. Каждая технология подразумевает определенную идею, которой нужно пользоваться.
Создание приложение консольного совсем не так делается, нежели создание приложения оконного.
Создание приложения оконного на базе Windows Form совсем не так делается, как создание приложения на основе WPF, т.е. там именно идеология другая, а не в том, что классы разные.
К примеру, у оконных приложений логика работы основана на событиях (событийно управляемый код), а в консольных приложениях ничего такого нет.
По каждой технологии есть документация.

Если необходимо создать приложение на платформе: ".Net" и уже есть техническое задание и понимание, что нужно заказчику, то:
1. Нужно подобрать необходимые технологии;
2. Если технология незнакома, то почитать документацию и изучить ее;
3. Создать проект, подключить библиотеки и писать код с их использованием;

Общий список технологий платформы: ".Net" и их возможности необходимо знать.

* У многих технологий, есть общая основа - это компоненты, которые их  объединяют. К примеру, это доступ к данным. Данные приходится забирать из различных источников данных в приложениях разного форм фактора. 

Наверняка, web-приложение или оконное приложение необходимо подключить к источнику данных (реляционная БД, файл в формате: xml, css и др. с информацией и т.д.). Ранее, чтобы подключить приложение к источнику данных, необходимо было изучить всю спецификацию источника и взаимодействовать с источникам только по средствам тех или иных протоколов, которые он поддерживает. Сейчас, есть технология: LINQ и другие, которые помогают оперировать данными посредствам создания объекта и манипуляций им с помощью методов (получить, удалить, записать и т.д.), что является несомненным преимуществом, так как позволяет глубоко не вдаваться в подробности, что происходит на стороне источника.

* Base Class Library (BCL) - это библиотека классов, на самом деле - это не одна библиотека, а несколько, которые содержат описание типов (bool, string, int и др.), которые являются компонентами библиотеки.

На каком бы языке не пришлось писать: VB, C#, F#, объявляемые переменные будут привязаны к базовому классу, в котором описаны тип. Но наименования типов в языках программирования могут отличаться, но базовый класс, к которому они будут привязаны будет один и тот же (пример: в C# есть тип: float, а в VB он называется: single).
Все преобразования к универсальному типу происходят в процессе компиляции. К примеру в C# есть тип: "short", который называется в системном классе: "int16" (аналогичный пример с типом: "int" в C#,  в системном классе он называется: "int32")

Помимо Base Class Library (BCL), есть и другие классы, которые предназначены для конвертации переменных разных типов, для математических операций, доступа к файлам и т.д.

Независимо от того на каком языке пишется программа и какой тип проекта, классы используются одни и те же.

* Common language Runtime (CLR) - это вся механика, которая позволяет приложению быть откомпилированным и запуститься.

## Историческая справка по платформе: ".Net"

".Net Framework" - это платформа для Windows. Последняя версия платформы 4.8, которая вышла в 2019 году.
C 2014 года - ".Net Core" - платформа для разных ОС. Текущая версия - ".Net 8" (начиная с версии 4 без слова: "Core")

Вначале компания Microsoft придумала платформу: ".Net Framework", данная платформа была ориентирована только для разработку приложений для Windows.
Спустя некоторое время, в 2014 году, компания Microsoft выпускает платформу: ".Net Core", которая была ориентирована также на кросс-платформенную разработку приложений для операционных систем: Linux, MacOS, Windows.
Приложения, созданные на платформе: ".Net Framework" нельзя было откомпилировать, чтобы они запускались на других операционных системах, кроме Windows, а приложения, созданные на платформе: ".Net Core" можно было откомпилировать, чтобы они запускались на других операционных системах.
До 2019 года платформы ".Net Framework" и ".Net Core" существовали, как 2 разных продукта, с 2019 года компания Microsoft объявила, что переходит на универсальную open-source платформу: ".Net".

*Сравнительная таблица платформ: ".Net" и ".Net Framework"*:

| .Net                                                | .Net Framework                                                      |
| --------------------------------------------------- | ------------------------------------------------------------------- |
| Linux, MacOS, Windows                               | Windows                                                             |
| Open-source, открытое к приложениям и изменениям    | Код доступен, но не открыт к изменениям                             |
| Полноценное развитие, добавление новых возможностей | Исправляются только критические ошибки по безопасности и надежности |
| Не распространяется вместе с ОС                     | Идет в комплекте с Windows и обновлениями Windows                   |

## CLR и JIT-компиляция


* **CLR (common language runtime)** - общеязыковая среда (виртуальная машина), которая отвечает за загрузку приложения, старт его и управление памятью.

Ранее, за управление ресурсами: память, драйверы, взаимодействие с устройствами и др. за это за все должен был отвечать программист, он выделял память, он обязан был следить за ее использованием и освобождением.
Типичные ошибки в приложениях на старых языках - это утечка памяти (memory leak). Особенно это чревато для общей работы приложения, когда это происходит в цикле или рекурсии. Другая опасность - это обращение не в нужную область памяти, а чужую - это чревато крахом и системными ошибками.

* Приложения с управляемым кодом (managed code).

Приложение старого формата, чаще всего были монолитными и ошибка в одной части программы, приводила к закрытию системы целиком. Сейчас архитектура современных информационных систем более гибкая и управляемая. Если вдруг, падает какой-то сервис, то это не приводит к краху всей системы, а просто не работает какая-то ее часть и у самой системы есть возможность определить ошибку и перезапустить сервис, т.е. обрабатывать ошибку управляемо.

Окончание: "ed" (manag**ed** code) - говорит о том, что это не наш код управляет чем-то, а нашим кодом управляют, т.е. наш код является пассивным элементом. Не мы управляем чем-то, а нами управляют. Данная ситуация была не очень понятна для "старожилов", так они сами привыкли выделять или освобождать память и т.д.
Если говорить о приложениях большого масштаба, то свобода выделения и освобождения памяти самостоятельно - это иллюзия, так как с данной свободой многократно возрастает и ответственность, ведь любая ошибка может привести к краху приложения или даже всей системы.  
Когда делегируем какой-либо структуре выделение и освобождение памяти, то это находится не под контролем, но об этом не нужно задумываться. В современном мире, большинство языков программирования работают именно по такой схеме:

* **GC – garbage collector (сборщик мусора)** - это автоматический менеджер памяти который периодически освобождает память, удаляя объекты, которые больше не используются программой. GC используется во многих современных языках программирования.


При запуске приложения происходит следующее:
1. Для приложения выделяются ресурсы, в первую очередь память;
2. В память выгружаются данные и сам программный код;
3. Управление передается программному коду;
4. Команды, которые записаны в программном коде - начинают выполняться, их выполняет специальный компонент, который называется **виртуальной машиной**;
Для приложения создается виртуальная машина и выполняет код. Выполняет - читает команду, интерпретирует ее и передает операционной системе на выполнение уже на языке самой системы. Таким образом, виртуальная машина является прослойкой между приложением и операционной системой.
Это дает кросс-платформенность, так как мы не обязаны в своем приложении разговаривать на языке операционной системы. Можем даже не знать, какая операционная система будет.
Задача виртуальной машины перевод кода в машинный код, для Windows своя виртуальная машина (среда выполнения) для MacOs - другая среда выполнения, но они все входят в ".Net", просто они разные для разных операционных систем.

Компания Microsoft принципиально изменила процесс перевода текста программы в машинный код.

В ".Net" используется средний подход между компиляцией и интерпретацией.
С одной стороны, действительно создается файл в формате: ".exe", который содержит команды не на родном языке. Все команды в нем уже переработаны компилятором в понятный и удобный для исполнения вид и там уже проанализированы все ошибки. 
С другой стороны, после компиляции исполняемый файл содержит не нативные команды операционной системы, а команды на специальном псевдоассемблере (макроассемблере), он в платформе: ".Net" называется: **IL (intermediate language)**.

**IL (intermediate language)** - это низкоуровневый язык, который с одной стороны, очень понятен и его не нужно переводить специально в машинный код, а с другой стороны, он независимый от платформы.

Задача виртуальной машины (среды выполнения), взять команду на языке **IL (intermediate language)** из исполняемого файла в формате: ".exe" и перевести данный код уже в машинную инструкцию и выполнить - этот процесс называется **JIT (just in time compilation)**.

## RID (runtime ID) идентификатор среды выполнения

У разработчиков на C# есть возможность переводить проект в переносимый формат или привязывать его к конкретной платформе (делать его зависимым от платформы).
Если привязывать проект к конкретной платформе, то его нельзя будет запустить на другой операционной системе, но приложение будет более быстрое и с большими возможностями для разработчика. В этом случае сама операционная система, а конкретно ее версия и разрядность записывается прямо в исполняемый файл и это называется **RID (runtime ID)**.

* **RID (runtime ID)** - идентификатор среды выполнения. Он есть только в случае, если проект непереносимый;
* RID содержит информацию о платформе ОС и архитектуре ЦП, на которых работает приложение ".Net"; 

*Пример*: 64-разрядная версия Windows, 64-разрядная версия Linux.

## Некоторые термины

**App model** - модель приложения (форм-фактор), это то что будет на выходе, как будет восприниматься пользователем, будет ли это вообще с пользователем взаимодействовать и каким образом все строится.
Примеры: ASP.Net, EF (entity framework), Windows Forms, WPF (windows foundation presentation)

**Assembly** – сборка, это часто исполняемый файл EXE или DLL файл, который может содержать одну или несколько наборов **API (Application Programming Interface)**, которые могут быть вызваны приложениями или другими сборками. Сборка находится в папке bin.

**API (Application Programming Interface)** - это программный интерфейс с помощью которого внешняя среда может взаимодействовать с сборкой. Это некий набор классов и в классах функций со своим названием и сигнатурой, который мы можем вызывать.

Для исполнительной среды, главное - это точка входа, т.е. это первая функция, которую мы можем вызывать и которая начинает работать и потом уже вызывает сама все остальное.
Для консольного приложения (среды выполнения) - это функция: "main". Для библиотек это весь набор классов и функций.

**Сборка (Assembly)** - это полноценный комплект файлов, необходимых для полноценной работы приложения или его использования.

**Ecosystem (экосистема)** - all of the runtime software, development tools, and community resources that are used to build and run applications for a given technology.
Под экосистемой понимается весь набор средств, который позволяет работать той или иной информационной системе. Это не только сам исполняемый файл (EXE), но и необходимые для его работы библиотеки, которые не только используются самой программой, но и те которые нужны для его запуска и исполнения. К примеру, классы для сборки мусора или сама виртуальная машина относятся к экосистеме. Иногда в экосистему могут входить средства, которые нужны в проекте, например, средства для обращения к базе данных или обращение к какому-то виду устройства.

В платформе: ".Net" компания Microsoft предлагает не какой-то один язык или библиотеки для него, а целую экосистему, которая работает бесшовно.

К примеру, есть проблема "стыковки", если приложение пишется на языке: Kotlin, PHP  и его нужно состыковать с базой данных Mongo DB или MS SQL Server. Из-за того, что продукты разрабатываются разными производителями, могут возникать проблемы в отсутствии схожих типов данных и т.д., которые не позволят быстро "состыковать" технологии.

Использование множества различных технологических решений от различных разработчиков - это альтернатива единой экосистеме разрабатываемой одной компанией или различными разработчиками под одним общим стандартом.

**.Net CLI (command-line interface)** - кроссплатформенное средство для разработки, компиляции, запуска и публикации ".Net"-приложений.

**Platform (платформа)**. Операционная система и аппаратная часть, на которой она работает. Например, Windows, macOS, Linux, iOS, and Android.

У слова: "платформа" несколько смыслов:
* Если говорить о платформе в контексте: ".Net", то это весь набор программных средств, разработанных компанией Microsoft для создания приложений;
* Если говорить о платформе в контексте компиляции приложения, то это связка операционной системы и аппаратной части, т.е. это какая разрядность операционной системы.

**Runtime** - исполняемая среда для управляемого приложения.

**Stack (стек)** - a set of programming technologies that are used together to build and run applications.
Стек - связка технических средств, которые используются для разработки приложения.

## Публикация приложения

Пользователю не нужны лишние манипуляции для запуска приложения, самый идеальный вариант - это ярлык приложения которое запускается при помощи ярлыка на рабочем столе.

Подробнее про публикацию приложения можно почитать на официальном сайте компании Microsoft или на каких-либо сторонних сайтах.

Для сборки проекта в Visual Studio, необходимо в верхнем меню нажать на подменю: "Сборка" и выбрать необходимую команду: "Собрать решение" или "Сборка %наименование приложения%".
При нажатии на команду: "Собрать решение" будут скомпилированы все отдельные проекты, которые входят в решение и которые могут быть написаны на различных языках программирования.

Компиляция происходит не быстро и это занимает значительную часть времени.

Можно запускать на компиляцию не все решение, а отдельные его проекты, если, к примеру, изменения были только в одном проекте, то можно скомпилировать только его, а для остальных будет использоваться старая версия. При этом решение придется пересобрать.

При сборе необходимо уточнять, что необходимо сделать с внешними библиотеками (не те которые написаны нами), всего 2 варианта:
* Обращаться к ним из специального репозитория. 
Библиотека лежит где-то в системной папке и достается кодом из нее. Это означает, что если наш исполняемый файл будет перенесен на компьютер пользователя, то мы ожидаем, что и у него на компьютере есть такая же библиотека, такой же версии. Это устанавливается из реестра библиотек, библиотека должна быть зарегистрирована в операционной системе по ее идентификатору (ID) она находится, но названия версий должны совпадать. 
При таком варианте, есть риски, что если библиотека не обнаружиться, то программа просто не запуститься.


* Альтернативный вариант, сформировать внешнюю папку, где разместить все необходимые библиотеки и тогда зависимость от наличия библиотек у пользователя пропадает.

Кроме всего, при сборке можно настраивать различные параметры для сборки.

В верхнем меню в подменю: "Сборка", есть команда: "Опубликовать выбранные элементы".
Публикация - это тоже самое, что и сборка, но плюс еще deployment решения на какую-то платформу, например, в облако или куда-то еще.
При использовании команды: "Опубликовать выбранные элементы", необходимо выбрать, куда именно нужно опубликовать приложение и задать необходимые при публикации параметры.

При публикации автономного приложения создается исполняемый файл, который включает среду выполнения и библиотеки .NET, а также приложение и его зависимости. Пользователи приложения могут запустить его на компьютере, на котором не установлена среда выполнения .NET. Автономные приложения зависят от платформы.

Автономная сборка хороша тем, что пользователю не нужно ни о чем задумываться. Передали пользователю папку с программой, он у себя ее запустил и все работает. Но размер программы очень большой, из-за копирования в папку с программой всех необходимых компонентов.

При публикации приложения в качестве зависимого от платформы создаются исполняемый файл и двоичные файлы (файлы DLL), включающие только само приложение и его зависимости. Пользователям приложения необходимо отдельно установить среду выполнения .NET. 

**В чем принципиальное отличие от запуска файла: ".exe" и ".dll"?!**

Есть 2 понятия файлов: ".dll" абсолютно разных и не нужно путать:
1. Есть понятие библиотеки в смысле шаблона проекта и при компиляции создается файл: ".dll" и там нет никакой функции: "main" и конечно же библиотеку не запустить через командную строку, библиотеку можно использовать другим программистам в другом проекте, подключаться к библиотеке и вызывать какие-либо функции;
2. Если проект создан на базе обычного консольного приложения, то при компиляции может создаться файл: ".dll" - это не будет библиотекой и данный файл можно запустить через командную строку, так как в нем будет функция: "main" (точка входа);


# Лекция Р3: Разработка проектов с использованием WinForms

## Объектно-ориентированный подход
Объектно-ориентированный подход - это была эволюция развития написания программы. Когда команд становится много и они сложны, то необходимо задуматься об организации программного кода, так как ориентироваться в коде без определенной структуры очень сложно (как убрать главы в книге, например).
Основным вопросом над которым задумались стал вопрос: А нельзя ли организовать код таким образом, как мы видим организацию объекта в окружающем мире. В окружающем мире мы сталкиваемся с осязаемыми сущностями - объектами (пульт, мышь), которые имеют определенные характеристики: длина, цвет, вес, количество кнопок, а также имеет определенные функции и события (например, индикатор топлива в автомобиле, он сообщает о недостатке топлива - инициатор события сам автомобиль). Так и появились понятия объекта и класса.
- Объект - это конкретная сущность с которой работаем в программе. 
- Класс - это тип объекта.
Объект наследует из класса, все, что там заявлено.
*Пример*: Можно объявить класс: "пульт" и сформулировать обязательные характеристики, которыми обладают все пульты, такие как: длина, ширина, цвет, вес. С другой стороны, пульт может иметь определенные специфические характеристики, которые может иметь только определенный пульт. Это очень похоже на статью в энциклопедии про тигра, статья будет классом, так как это некая абстракция, а реальный тигр, которого можно встретить в природе - это будет объектом класса, он будет иметь свой цвет, вес, возраст и т.д. - это объект созданный на базе класса.

Объект состоит из:
- Method - метод. Действие, применимое к объекту. Метод - это аналог функции, это действие, которое можно выполнить с объектом. Метод применяется к конкретному объекту. Пример: есть объект: "кнопка" и необходимо ее передвинуть, метод будет: "move", а записать можно: Button.Move.
- Event - событие. Информирование владельца объекта. Способ уведомления владельца объекта о том, что с ним произошло. 
- Property - свойство. Характеристика объекта. Также как и переменная имеет свое название и тип. В отличие от простых переменных, свойство не может быть само по себе (нельзя написать x = 100), нужно написать название объекта и имя свойство через точку (пример: Object.X).

В C# есть возможность реализовать свойства по разному: только для чтения, только для записи, или можно записать  один раз свойство, а потом оно не будет меняться, также есть возможность при обращении к свойствам запускать определенный код.

Control - объект, элемент интерфейса.

## Проект с оконным интерфейсом

Технологий создания приложений с оконным интерфейсом много и у каждой есть свои плюсы и минусы.
Мы будем работать с технологией: WinForms, она немного устаревшая, есть более современные технологии (WPF, MAUI), но они имеют и сходство между собой.

1. Разработать Desctop-приложение можно базируясь на разных технологиях: WinForms, WPF, MAUI;
2. Чудеса ниоткуда не берутся, не смотря на то, что проект с необычным внешним видом, но если заглянуть в код, то там те же операторы на C#, которые взаимодействуют с другими библиотеками, классами, но многие моменты очень похожи с созданием контрольного приложения;
3. Многие действия по созданию оконного приложения можно сбросить на саму среду: Visual Studio, такие как: 
	* Проектирование форм. Кнопки можно определять при помощи мыши, задать размер и т.д. при помощи мыши, т.е. работа как в конструкторе, а сама среда уже пишет необходимые операторы в коде;

### Отличия консольного проекта от проекта с оконным интерфейсом:

* В проекте обязательно будет присутствовать модуль (класс) типа: "Form" (один или более). Модуль имеет 2 режима работы: "Область дизайнера" (можно работать с интерфейсом) и "Область кода". В обычном проекте - это не так, так там класс имеет 1 режим работы. Классов типа: "Form" может быть несколько.

* Форма (Form) – класс, прототип окон. На базе класса формы создается объект (объекты) окно (экземпляр класса). 

* Точка входа программы не функция main, а конструктор формы (процедура создания окна). После того, как окно создано, оно переходит в режим ожидания. Это принципиально меняет всю философию. Когда форма загрузилась, программа перешла в режим ожидания и дальнейшее зависит от того, какие действия будет совершать пользователь или другая система. 

Если пользователь нажмет мышкой на одну кнопку, то возникнет одно событие и вызовется одна функция, а если на другую кнопку, то возникнет другое событие и вызовется другая функция. Заранее сказать в оконном приложении какое действие возникнет первым и потом в каком порядке будут возникать остальные - нельзя.

В консольном приложении порядок выполнения функций зависит от порядка функций, который мы написали и его можно как-то спрогнозировать, то в оконном приложении это практически сделать невозможно.

Действия, которые возникают при нажатии мышкой пользователем или нажатия на клавишу - это событие. Вернее не действия а сигнал, что некоторая реакция случилась и программа ожидает ответной реакции - это события.
События - это некий программный механизм, он привязан к конкретному объекту, например: "кнопке" и конкретной ситуации, например: "щелчок". 
Реагирования на событие будет, если есть функция: "Обработчик событий" (event hendler). Главная особенность данной функции, что она привязана к событию. Это означает, что функция автоматически системой вызовется в ответ на событие (пользователь щелкнул по кнопке и вызвался обработчик события).

### Особенности разработки оконных приложений

*Варианты реализации оконных приложений*: 
- Одна форма, одно окно;
- Одна форма, несколько окон;
- Несколько форм, несколько окон (одно окно - основное и много вспомогательных окон);

Каждый вид окна должен быть отдельно запрограммирован, это обычно делается, когда в проект добавляется новый модуль класса, этот класс не простой - это модуль класса.

Когда создается проект в Visual Studio для разработки оконных приложений, необходимо выбрать шаблон: Windows Forms. И в соответствие с данным шаблоном, в проект будет добавлено 2 модуля:
- модуль стандартного типа (с которым привыкли работать). Он будет выполнять функцию системного модуля и в обычной ситуации изменять что-то там нет нужны;
- модуль формы. Он имеет 2 составляющих:
	- Область кода. Окно для редактирования и написание кода;
	- Дизайн-интерфейс. в данном режиме можно настраивать дизайн формы, размещать объекты, менять их, настраивать свойства и т.д.;

Сохраняется все в файле с расширением: ".cs", но у модуля формы есть еще и файл конфигурации.
Формой будем называть шаблон, сам по себе класс, а окном будем называть объекты, которые создаются на базе этой формы.
С окнами можно производить операции пользователю, а с формой имеют отношение разработчики.

Класс формы: "Form1" необычный он производный от родительского класса: "Form".
Еще одна особенность - это  подключаемое пространство имен: using System.Windows.Forms; 

Структура модуля формы:
- Пространство имен;
- Заголовок класса;
- Конструктор класса;
- Обработчик события;

Косвенно затрагивается тема архитектуры приложения. Один из распространенных подходов к архитектуре приложения - это 3-х уровневая архитектура:
- GUI (Graphical User Interface) - графический интерфейс пользователя;
- BL (Business Logic) - бизнес логика;
- DL (Data Logic) - логика данных (прослойка между хранилищем данных и бизнес логикой, чтобы бизнес логике не нужно было разбираться физически в данных, где они находятся);

Такая модульная архитектура кажется избыточной для тех, кто не создавал большие проекты.
Такой компонентный подход позволяет менять компоненты без рисков затронуть или сломать другие компоненты системы.
Преимущества архитектуры компонентного подхода:
- Легкая и удобная замена компонентов;
- Распределение работ между разными программистами;
- Быстрый поиск и исправление ошибок и т.д.;

Для создания нового проекта в одном решении, нужно вызвать контекстное меню, щелкнув правой кнопкой мыши в окне: "Обозреватель решений" в Visual Studio, на решение, а затем нажать кнопку: "Добавить" и создать модуль класса.

Модули нужно создавать осмысленно, понимать, какой у них будет контекст и какое содержание. Обычно в модули выделяют какой-то отдельный функционал, который может отдельно рассматриваться, как отдельная единица (отдельный компонент).

При удалении компонента, файл будет удален из проекта и с диска в том числе.
Желательно, чтобы имена класса и файла на диске совпадали.

Структура - это такой тип данных, который позволяет скомпоновать вместе в одну переменную значения разных типов (ФИО, email, дату рождения и т.д.).

```C#
// Пример объявления структуры
namespace PhoneBook
{
	public struct SItem
	{
		public string LName
		public string FName
		public ulong Phone
		public string Email
	}

}
```

Когда переменная "закрывается" (используем ключевое слово: "private"), доступ к ней ограничивается и структуры 

Способы проверки вводимых значений в консольном приложении:
- Проверка делается в ручном режиме перехватом символов в водимом поле;
- Использовать masked textbox. Оптимальный вариант для нас;
- При добавлении значения делать проверку (самый плохой способ). Он не в стиле оконного приложения, а в стиле консольного;

Объектам желательно присвоить корректные имена, если к ним идет обращение в коде.
Правильный выбор объекта интерфейса существенно облегчает жизнь, необходимо использовать объекты по своему назначению.

Если пишем код, который связан с действием, приходящим из-вне, то это должен быть обработчик события.

Если пользователем 
объявляем переменную tb и в нее записываем объект
```C#
// Пример объявления структуры
private void txtLName_TextChanged(object sender, EvnArgs e)
{
	TextBox tb = (TextBox) sender;
	tb.Text = "Пишу текст";

}
```
Такой прием используется, когда нужен один обработчик на множество объектов

В свойство Enable объектов: "Button" записывается: "true", если кнопка разблокирована и "false", если кнопка заблокирована.

*Примечание*: Проект с оконным приложением отправляется всей папкой целиком.



# Лекция 1_2: Массивы

## Понятие массива

**Массив** - это именованная область памяти, состоящая из однотипных, проиндексированных элементов.

*Пример одномерного массива*:
![[Pasted image 20260220000404.png]]

*Пример синтаксиса объявления одномерного массива*:
```C#
[public | internal | private] type[] arrayname;
 
[public | internal | private] type[] arrayname = new type[size];

// size – это количество элементов в массиве
```

***Важные моменты***:
1. Все ячейки находятся в памяти в одном блоке, ячейки соседние и не могут находится в разных местах в памяти;
Эта особенность позволяет обратиться к ячейке зная ее индекс. К примеру, если необходима ячейка под индексом: "7", то "int" (4 байта) умножаем на 7 получим 28 и смещаемся от начала на 28 байт и получим значения в ячейке с индексом: "7".
Таким образом обращение к ячейке массива происходит за единицу времени, но это не всегда так, к примеру, в списках так не получится сделать, там недостаточно умножить индекс на размер, так как там ячейки могут находится где угодно и не обязательно в соседних ячейках.
Минус массива: если необходимо вставить ячейку между двумя соседними ячейками, то так просто не получится сделать, придется выполнять операции копирования массива в соседнюю ячейку памяти.
2. Индексы. На сомом деле, никаких индексов в памяти нет, есть просто память выделенная для ячеек и там хранятся значения (массив числовой - хранит числа). Индексы - это некоторая условность.
Индексы есть только в понимании программиста (понимании алгоритма) и когда мы обращаемся к ячейке массива a\[7], то это служит информацией для компилятора, что нужно сделать (нужно взять размер ячейки и умножить на 7, таким образом посчитать на сколько байт сдвинуться и обратиться в нужное место). Обычно, современные компиляторы все это делают заранее.

Формула: offset = index * size
Где: 
- offset – смещение в байтах
- index – индекс элемента
- size – размер одного элемента в байтах.

3. Ячейки однотипные. Требование однотипности, гарантирует, что размер всех ячеек одинаковый и мы можем посчитать смещение. В этом есть сила массива.

Вопрос: Если ячейки типа: "string" (которые имеют различную длину), то как компилятор может корректно посчитать куда сместиться?
Массив с типом: "string" содержит ссылку на область памяти, в которой уже хранятся коды символов и столько символов, сколько нужно. Это не противоречит требованию однотипности ячеек, а ссылка на тип: "string" одинакового размера.

*Примечание*: Ссылки на объекты тоже могут иметь разный размер

*Преимущество использование массивов*:
- Структура представления данных;
- Экономия сил программиста;
- Эффективный обход и обработка элементов;
- Динамические массивы;

## Массив - переменная

**Массив - это переменная**, у нее есть имя и все характеристики, как у переменной, переменная не обычного типа, а объектного.

*Характеристики переменной*:
- Имя;
- Область видимости;
- Время жизни;

Массив можно объявлять, как и простые переменные, внутри функции, тогда они будут локальные или внутри цикла/блока, можно объявить за пределами функции (private/public), тогда массив (переменная) будет либо закрытая, либо публичная (видна везде).

**Отличия массива от переменной**:
1. Размер. 
Когда мы говорим: "Размер переменной", то имеем в виду, сколько памяти для переменной выделено (пример: размер переменной с типом: "int" = 4 байта).
Размер массива, не совсем корректно считать, как размер переменной. Массив - это переменная ссылочного типа, она хранит ссылку. Ссылка занимает тоже какую-то память, но имеется в виду, область памяти, которую занимают ячейки массива. Чаще всего, когда говорят: "размер массива", то подразумевают размер не в байтах, а количество ячеек массива.
2. Размерность.
Данная характеристика, характерна только для массива и она определяет, как ячейки организованы и как к ним осуществляется доступ.

*Пример*: Если взять 100 кубиков (100 ячеек), то как их можно выложить на столе?
Самый простой вариант: выложить в линию и это будет соответствовать одномерному массиву.
Можно выложить кубики в виде прямоугольника, размером 5х20 или 4х25 или 2х50 - это примеры двухмерных массивов, у которых размер одинаковый, но конфигурация разная.
Можно привести пример трехмерного массива (слои), выстраивается в объемную фигуру.

*Примечание*: В памяти компьютера никаких кубиков, которые так выстраиваются - нет, в памяти компьютера, массивы могут быть 4-х мерные, 5-ти мерные, 6-ти мерные и т.д. Привязываться к геометрии не стоит, эта аналогия только для первичного понимания особенностей организации данных.

Размерность определяет способ доступа к ячейке, какова размерность, столько индексов и необходимо указать для доступа к ячейке. Если массив 4-х мерный, то необходимо указать 4 индекса (4 координаты), чтобы в 4-х мерном пространстве обратиться к конкретной точке, в 3-х мерном - 3 координаты (x,y,z), в 2-ух мерном 2 координаты (x,y).

Число ячеек зависит от того, сколько данных необходимо хранить и если данных 100, то нельзя объявить размер другого массива. Теоретически, все массивы могут быть одномерные, вопрос только в том, как удобнее.

Индексация ячеек начинается от: "0" (нуля), а при объявлении массива, указывается количество ячеек и поэтому, максимальный индекс отличается от количества на "1" (единицу).

3. Ссылочный тип. 
Массив - это переменная ссылочного типа, она хранит ссылку на область памяти, где находится значение.

*Пример двухмерного массива*:
```C#
static void Main ()
{
	int[,] arr = new int[4,2];
}
```

| arr\[0,0] | arr\[0,1] |
| --------- | --------- |
| arr\[1,0] | arr\[1,1] |
| arr\[2,0] | arr\[2,1] |
| arr\[3,0] | arr\[3,1] |

## Особенности массивов в C\#

- Переменная массив - является объектом, созданным на базе класса: Array.
В классических языках (C или Pascal) нет классов, есть понятие массивов и это не связывается с термином класса.
Информацию о классе: Array, можно найти в документации и в object browser, можно посмотреть, какие там есть свойства или методы. Событий в классе нет.

- Массивы ссылочного типа, производные от абстрактного типа (класса) Array (сборка System);
- Array - это абстрактный класс, представляющий методы и свойства. Создать объект типа Array - нельзя, необходимо уточнение типа, размера и размерности.

**Важно**: Отличие объектов, созданных на базе класса, от простых переменных, созданных на базе обычных типов в том, что объект нужно не просто объявить, а еще и создать при помощи слова: "new" (это один из вариантов, он базовый).

*Пример*:
```C#
	int[] array1 = new int[5];
// При использовании слова: "new" вызывается конструктор, он выделяет память нужного размера, ссылка записывается в переменную: array1
```

Массив можно пересоздавать (создать -> уничтожить -> создать снова), с простыми переменными так не получится.
Уничтожение массива равнозначно освобождению памяти (ссылка будет null)
Пересоздание массива означает изменение ссылки на другую область памяти.

Иногда мы можем принудительно пересоздать массив, а иногда это делает вызывающая функция, к примеру, при изменении размера массива (resize).
При изменении размера массива (resize), выделяется новая память большего размера, данные из старой памяти копируются в новую память, а старая память освобождается.

У объектов можно вызывать методы и свойства. Обращение к свойствам делается через точку.

*Пример*:
```C#
	int[] array1 = new int[5];
	Console.WriteLine (array1.Length);
```


## Объявление и создание массива в C\#


```C#
// Объявление массива без создания ячеек
int[] array0;

// Объявление одномерного массива из 5 ячеек
int[] array1 = new int[5]; 

// Объявление и инициализация ячеек значениями
int[] array2 = new int[] {1, 3, 5, 7, 9};

// Объявление и инициализация ячеек значениями (другой способ)
int[] array3 = {1, 2, 3, 4, 5, 6};

// Объявление двухмерного массива 
int[,] multiDimensionalArray1 = new int[2,3];

// бъявление и инициализация двухмерного массива
int[,] multiDimensionalArray2 = {{1,2,3},{4,5,6}}

```


## Элементарные операции с массивом в C\#

```C#
// Чтение и запись
array1[1] = 100;
Console.WriteLine (array1[1]);

// Использвоание переменных
j = 2;
array1[j] = j * 10 + 1
```

*Примечания*: 
- Индекс необходимо указывать в корректных пределах, если массив размером 100, то при указании значения: 105 будет ошибка;
- В качестве индекса можно указывать переменную;

Когда необходимо написать функцию, которой необходимо передать массив, то указывается аргумент необходимым образом, то подразумевается, что он существует и уже заполнен и работа идет с данным массивом. 
При этом данные о массиве, получать необходимо через его свойства.

```C#
public static void SumArray(int [] arr)
{
	int sum = 0;
	foreach(int n in arr) sum += n;
	return sum;
}
```

**Важно**: 
- Так как массив ссылочный тип данных, то при изменении значения ячейки в функции, в массиве значение поменяется.
- "ref"  в аргументе в функции нужно писать тогда, когда в ней меняется сам массив, к примеру, в функции пересоздается массив, вызов конструктора или изменении размера (resize).


## Динамический массив

Термин динамический массив существует с давних времен. В старых языках программирования можно было объявлять динамические и статические массивы;

**Статический массив** - это массив, размер которого в течение работы программы не меняется.
**Динамический массив** - это массив, размер которого в течение работы программы можно менять.

В старых языках программирования, динамические массивы были сопряжены с некоторыми сложностями на уровне компилятора с ними сложнее строилась работа.
В современных языках программирования, разделение на динамические и статические массивы ушло.

В C#, массив - это объект класса Array, а у класса Array размер (число ячеек) можно менять. Нельзя объявить так массив, чтобы его размер невозможно было изменить, если только не запрограммировать свой класс или использовать другой класс.

Для изменения размера массива в C# используется метод: Array.Resize()

У метода: Array.Resize() есть ограничение, он позволяет изменять размер только для одномерного массива. 
Если необходимо изменить размер у двухмерного массива, то необходимо самим это запрограммировать, для этого нужно:
- объявить новый массив другого размера;
- скопировать данные из старого массива в новый;

*Пример использования метода Array.Resize*:
```C#
//Абсолютный вариант (если массив больше, то данные потеряются)
Array.Resize(ref arrNums, 4);

//Относительный вариант (отталкиваемся от текущего размера массива)
Array.Resize(ref arrNums, arrNums.Length + 5);

```

Так как Array.Resize операция очень трудоемкая (выделение новой области в памяти и копирование) и каждый раз вызывать метод: Array.Resize и добавлять увеличивать размер массива на 1 ячейку - это не оптимальный вариант.

*Рекомендация*: Если читаются данные из файла и неизвестно, какого размера необходимо создать массив, то можно использовать следующие варианты:
- Если есть возможность сделать предварительную оценку "сверху", то необходимо изменить размерность массива, исходя из оценки, а не заполненные ячейки потом убрать;
- Если возможности сделать оценку "сверху" нет, то необходимо увеличивать размер массива с определенным шагом, если останутся незаполненные ячейки, то потом их убрать;


## Некоторые операции с классом Array

```C#
//Копирование массива
array1 = array2;

//Копирование значений массива (массивы должны иметь одинаковую размерность, array2 должен иметь достаточное количество ячеек)
Array.Copy(array1, array2, 4);

//Клонирование массива
array2 = (int[,])array1.Clone();

//Изменение размера массива (только для одномерных массивов)
Array.Resize(ref array1, 10);
```

Статические члены класса - это такие члены класса (либо метод, либо свойство), которые вызываются не применительно к объекту, а применительно к классу (**Array**.Resize).

При использовании оператора присвоения "=" применительно к переменной, то значения одной переменной, копируется в другую переменную (x = y).

При использовании оператора присвоения "=" применительно к массиву, происходит копирование ссылки, а не копирование ячеек.

Прямого метода, который бы гарантировал клонирование массивов нет, потому, что глубина вложенности ссылок может быть большая. В нашем массиве, ячейка может содержать ссылку на другой массив, а тот массив может содержать в ячейках ссылки на какие-то другие массивы и т.д.


## Ступенчатый массив (jagged array)

**Ступенчатый массив** - это массив каждая ячейка которого содержит ссылку на другой массив и не обязательно, что размерность вложенного массива будет совпадать с "основным".

Создать за 1 раз ступенчатый массив не получится, вначале создается базовый массив, а далее для каждой ячейки создается свой массив.

*Синтаксис ступенчатого массива*:
```C#
array[][] = arrJag;
arrJag = new int[3][]; // базовый массив
arrJag[0] = new int[10];
arrJag[1] = new int[20];
arrJag[2] = new int[30];
```

Когда ступенчатый массив не нужен, это когда есть массив с информацией об оценках студентов, то это типичный двухмерный массив, по строкам фамилии студентов, по столбцам названия предметов, на пересечении оценка конкретного студента за конкретный предмет.

Ступенчатый массив может подойти, если мы хотим хранить информацию о температуре, замеряемой каждый день 1 раз в разрезе месяцев. В таком случае, в каждом месяце различное количество дней и обращаться к данным будет удобно.

В силу некоторых сложностей, когда можно отказаться от ступенчатого массива, лучше от него отказаться. Альтернатива, к предыдущему примеру, все же сделать массив двухмерный 12х31

**Рекомендация для решения задач**:
Какой массив использовать для хранения данных? Имеется в виду, какой тип ячейки, какой размерностью будет массив (одномерный, двухмерный, трехмерный и т.д.).
Если есть сложности с пониманием, как объявить массив, то необходимо подумать, что массив уже есть и как бы необходимо обратиться к ячейке массива. Сколько индексов нужно указать, чтобы к ячейке обратиться - это и есть ответ на вопрос, какая размерность и будет.
























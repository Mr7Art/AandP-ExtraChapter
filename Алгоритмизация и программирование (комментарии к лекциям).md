# Лекция 1: Алгоритм. Исполнитель. Языки программирования

**Программное обеспечение (ПО)** - программа на заказ;
**Проприетарное (частное/собственное) ПО** - в основном, распространяется по соглашениям и за определенную плату;
**Открытое ПО** - ПО с открытым исходным кодом, не всегда бесплатное;
**Свободное ПО** - подразумевается, что лицензионное соглашение не подразумевает финансового вознаграждения разработчику. Распространяется по лицензии.  

**Алгоритм** – пронумерованный список однозначных и понятных для исполнителя указаний (инструкций), направленных на решение задачи за конечное число шагов.

Универсальный исполнитель характеризуется следующими особенностями:
* внутренняя память;
* система внешних команд;
* система внутренних команд (способность управлять другими исполнителями);

*Пример*: робот пылесос, кондиционер, человек и др.

Язык программирования - формальная знаковая система, предназначенная для записи компьютерных программ.

Формальные языки характеризуются:
* допустимое множество лексем (алфавит) конечно;
* фразы, которые можно составить из лексем однозначны; 

*Примеры формальных языков*: ноты (нотная грамота), запись шахматной партии

Язык программирования состоит из:
- Алфавит (лексема);
- Синтаксис (синтаксические правила);
- Семантика (смысл записанного); *Пример*: знак: "=" может быть присвоением или чем-то другим;
- Прагматика (информация о том, как команда выполняется);

Способ определения языков:
- Перечисление всего множества допустимых последовательностей лексем;
- Задать правила для генерации корректных последовательностей лексем;
- Задать правила для проверки на корректность последовательностей лексем;

**Классификации языков программирования:**

*Классификация языков программирования по уровню абстракции*:
- Машинные коды - нативный язык, который понимает вычислительна система;
- Языки программирования низкого уровня (ассемблеры) - имели мнемонические обозначения команд;
- Языки программирования высокого уровня (ЯВУ) - удобство для разработчика;
- CASE системы = computer aided software engineering (разработка ПО с помощью компьютера) - системы автоматизирующие деятельность; 

*Классификация языков программирования по парадигме:*
Парадигма - набор воззрений, идей, концепций, шаблонов для выполнения действий, которые все в совокупности позволяют решать задачу или получить определенный результат.
Парадигма близка по своей сущности к такому явлению, как направление в живописи.

1. Неструктурные (BASIC)
2. Императивные (языки, основанные на концепции, что программа состоит из инструкций, отвечает на вопрос: делай это): 
	- Структурные (Fortan ...) - подразумевает, что можно формировать структуру, как в книге, блок - вложенный блок и т.д.;
	- Процедурные (C, Pascal ...) - позволяют выделять самодостаточные фрагменты кода в отдельные автономные блоки, функции или процедуры; 
	- Объектно-ориентированные (C++, VB, C# ...) - были придуманы тогда, когда программист "потерял нить, связывающую реальность с программным кодом" (основная идея подхода). Главная цель, ускорить написание кода и удобство;
3. Декларативные (программа состоит из описания, пример: \<HTML>):
	- Функциональные (ЛИСП, Haskell, F# ...);
	- Логические (Пролог ...);

Спагетти код - это когда автор использовал много операторов go to (оператор перехода).

# Лекция 2: Система программирования

Отличие среды программирования (СП) от языка программирования (ЯП):
- Транслятор;
- Средства создания и редактирования текста;
- Библиотеки (наборы) стандартных типов;
- Инструменты выполнения и отладки;
- Встроенная справочная система;
- Дружественный интерфейс;

После выбора СП, начинается все с создания нового проекта, в Visual studio следующая иерархическая структура (сверху-вниз):
- Решение (solution) - задача, которую необходимо запрограммировать;
- Проект (project) - подзадача, в простейших задачах, проект один, а в сложных случаях их может быть много (пример: выделение "сервисных операций" (орфография, поиск синонимов и т.д.) в отдельный проект при написании текстового редактора);
- Модуль (module) - единица кода, самостоятельная (автономная), сохраняется в файле на диске, модули можно разделить на программные (код) и все остальные;
- Подпрограммы / функции (sub);

*Примечание*: В простейших задачах, решение (solution) и проект (project) будут одни.

Транслятор - переводит код, написанный на высокоуровневом языке в машинный.

Трансляция (транслятор) бывает 2-ух основных типов:
1. Компиляция (вид транслятора: Компилятор) - переводит в машинный язык исходные файлы, написанные на высокоуровневом языке, применяя специальные правила при переводе. После завершения компиляции, получается исполняемый файл, обычно, расширение скомпилированного файла: exe (от англ. executable исполняемый); Примеры ЯП: C++, Fartan
2. Интерпретация (вид транслятора: Интерпретатор) - интерпретатор последовательно читает команды из исходного файла, все это происходит в оперативной памяти. При интерпретации, никаких исполняемых файлов не создается. Примеры ЯП: JavaScript, VBA

C# является гибридным и относится и к первой группе и ко второй.
C# берет исходные файлы и переводит на специальный язык: IL (intermediate lenguage), низкоуровневый язык, независящий от аппаратной части. Потом, все записывается в исполняемый файл (exe). Когда исполняемый файл выполняется, то должна работать виртуальная машина, которая должна быть на компьютере.

Плюсы компиляции: скорость работы программы, среда программирования не обязательна (с оговорками, к примеру, должны быть библиотеки), зависимость от наличия транслятора, защита исходного кода (+-);
Плюсы интерпретируемого подхода: переносимость (программу, можно перенести на другие системы), процесс отладки, возможности модификации;

Подходы к компиляции:
- Статическая компиляция - при таком подходе, компилятор берет программный код функции и вставляет в исполняемый файл, таким образом, зависимость от библиотеки пропадает;
- Динамическая компиляция - в исполняемый файл вставляется ссылка на библиотеку (указывается идентификатор библиотеки и идентификатор функции) и когда программа доходит до нужного места, то среда выполнения подгружает библиотеку;

Плюсы статической компиляции: независимость от внешних файлов. К примеру, программа должна работать с внешнего накопителя.

На практике чаще применяется динамическая компиляция.

Плюсы динамическая компиляции: размер исполняемого файла (небольшой), информация не дублируется на жестком диске компьютера, обновление библиотек будет происходить просто.

Расширение у библиотек: .dll (dynamic link library - динамически подсоединяемая библиотека) - в процессе работы библиотека подгружается в оперативную память и можно с ней работать.

Дистрибутив - архив, содержащий все необходимое для установки программы. Процесс установки файла дистрибутива на компьютер, называется *инсталляцией* (установкой).

Слова: дистрибутив и инсталляция, присущи динамической компиляции.

# Лекция 3: Алгоритм. Исполнитель.

**Алгоритм** – пронумерованный список однозначных и понятных для исполнителя указаний (инструкций), направленных на решение задачи за конечное число шагов.

Исполнителя характеризуют:
- среда - где исполнитель функционирует, среда может влиять на работу исполнителя;
- элементарные действия - те действия, которые исполнитель выполняет в ответ на команду;
- система команд - то, что исполнителю подается и то что он может расшифровать;
- отказы - поведение исполнителя в случае форс-мажорных ситуаций;

Основные свойства алгоритмов:
- Дискретность (прерывность, разделенность) - обозначает, что алгоритм не является монолитным и его можно разделить на отдельные команды, которые можно выполнять. Свойство позволяет адресоваться к той или иной команде. Каждая команда должна выполняться за конечное время;
- Определенность - команды должны быть четкими и понятными для исполнителя;
- Результативность (конечность) - результат для которого алгоритм создан, должен достигаться за конкретное число шагов;
- Массовость - алгоритм должен корректно и одинаково работать для любых входных данных из допустимого множества;

Машина Тьюринга - абстрактный исполнитель (абстрактная вычислительная машина), используемая для формализации понятия алгоритма. В машине Тьюринга исполнитель не может заглядывать вперед, а выполняет все шаг за шагом и остановится на определенном  шаге, если не сможет его выполнить.

Исполнитель в машине Тьюринга имеет:
1. Алфавит - набор допустимых команд, который исполнитель понимает;
2. Состояние - набор неких ячеек внутри исполнителя которые хранят определенные данные (может изменяться);
3. Правила - сопоставление команд неким действиям;

После выполнения команды исполнитель по умолчанию, продвигается на ленте на 1 ячейку вперед;

Новое в связи с AI: Исполнитель на уровне нейросетей умеет рассуждать и запоминать свой предыдущий опыт.

Формы представления алгоритма:
- Представление на естественном языке;
- Графическое представление (блок-схемы);
- Представление на ЯП:
	- nocode / lowcode;
	- ЯП высокого уровня;


Оформление алгоритмов:
- Использование подмножества формального языка;
- Использование идентификаторов (имена переменных);
- Использование общепринятых математических или логических выражений;
- Проверка на соблюдение свойств;
- Вспомогательные алгоритмы (при необходимости);

Правила оформления внешнего вида блок-схем:
- Вертикальные или горизонтальные линии;
- Придерживаться вертикалей;
- Ход алгоритма: сверху вниз;
- Описание переменных;
- Название алгоритма;

Как придумывают идею алгоритма: поиск готового решения в доступных источниках;

Алгоритм Евклида (поиск НОД): Есть 2 числа. Нужно большее число поделить на меньшее и найти остаток от деления. Если остаток от деления равен 0, то второе число (на которое делили и есть ответ), если остаток от деления не равен 0, то заменяем остатком от деления большее число и проходим по алгоритму еще раз.

Алгоритм должен начинаться с заголовка. Ниже заголовка можно дать расшифровку условным обозначениям.

*Блок-схема и блоки которые необходимо использовать при выполнении заданий*:
![[Pasted image 20251012195102.png]]

*Приемы работы с алгоритмами*:
- Декомпозиция задачи (разбиение задачи на самостоятельные подзадачи без их дублирования);
- Модуль и иерархическая структура (самодостаточные блоки);
- Абстрагирование (Парадигма черного ящика - чтобы воспользоваться объектом не обязательно знать, как он устроен. Пример: использование микроволновки (не все знают, как она устроена, но используют ее). Черный ящик должен быть так спроектирован, чтобы его конструкция не влияла на его использование);
- Нисходящие и восходящее программирование (При нисходящем программировании - задачу рассматриваем сверху-вниз, начинаем с глобального и опускаемся до конкретных задач. Пример: стройка загородного дома. При восходящем программировании - задачу рассматриваем снизу-вверх, начинаем с конкретных задач и поднимаемся выше);

*Приемы (подходы) в программировании*: 
- сборочный (программист все собирает из "блоков" (кубиков), когда все готово и его задача все интегрировать. Ускоряет процесс разработки новой системы);
- конкретизирующий (Среднее между подходами (сборочным и синтезирующим). Использование полуготовых шаблонов, их настройка, дообучение и интегрирование их в разрабатываемую систему); 
- синтезирующий (программист сам все пишет под себя, свою систему, сам проектирует и сам программирует);

# Лекция 4: Организация ЭВМ

Основные элементы ЭВМ необходимые для рассмотрения (упрощенная схема):
- Процессор;
- Оперативная память;
- Устройства ввода и вывода;

*Процессор* - сложная микросхема. Нужно собственное охлаждение. Можно разделить на 2 части: 
- УУ (устройство управления);
- АЛУ (Арифметико-логическое устройство);
УУ содержит регистры (ячейки) команд и счет команд (список команд которые будут выполняться). 
АЛУ содержит регистры операндов (хранят те данные которые мы обрабатываем) и сумматор (вычисляет различные операции).

*Оперативная память* - играет пассивную роль, служит для хранения данных, можем записать или прочитать данные. Память энергозависимая. Большой набор ячеек (бит). Ячейки универсальны, можно записывать, как команды, так и данные.
Конструкция оперативной памяти очень сложна и она принадлежит не только одной программе;

*Принципы построения ЭВМ (архитектура Дж. Фон Неймана)*:
- Принцип использования двоичного представления данных и команд. В компьютере и команды и данные - это числа, которые хранятся в двоичной системе;
- Принцип программного управления. Все управление происходит посредством программ из которых состоит программа;
- Принцип однородности памяти. Ячейки памяти одинаково подходят для команд и данных;
- Принцип адресности. Для обращения к ячейкам памяти используются адреса, которые тоже являются числами;
- Принцип последовательности выполнения управляющих команд. Любая программа автономна, автор не должен находится рядом, чтобы программа работала.

Прагматика - информация о том, как команда выполняется внутри. Деление на 2 можно попробовать сделать побитовым сдвигом при определенных условиях.


# Лекция 5: Информация. Данные

Информация - общеупотребительный термин.
Источник информации - объект от которого исходит информация;
Приемник информации - объект, которому предается информация, который воспринимает информацию;
Канал передачи информации (воздушное пространство и т.д.)

С информацией можно проводить различные действия (создавать, передавать, запоминать, искать, разрушать и т.п.)

Форма существования информации может быть различной, например, световые (звуковые/радио) волны, знаки на бумаге, форма магнитных полей и т.д.

Свойства информации:
- *Достоверность*. Свойство информации, которое оценивает то, на сколько та информация, которую получил приемник совпадает с тем, которую отправил источник;
- *Полнота*. Свойство информации, говорит о том, на сколько достаточно информации для принятия решения;
- *Ценность*. Свойство говорит о том, на сколько нужна информация для выполнения определенной задачи;
- *Актуальность*. Свойство говорит о том, на сколько в процессе работы алгоритма устарела информация.
- *Понятность*. Свойство говорит о том, на сколько получатель информации может ее воспринять.

***Данные (data)*** - это информация, представленная в формате пригодном для хранения и обработки на компьютере.

Для записи множества данных используются структуры данных (деревья, очереди стеки и т.д.).

Информационный обмен между процессором и оперативной памятью осуществляется через шину.

64 разрядная архитектура - означает, что компьютер манипулирует информации блоками с размером 64 бита. Т.е. 64 бита считываются за раз, регистры в процессоре тоже имеют 64 бита (предыдущие компьютеры имели разрядность 32 бита).
64 бита (8 байт) - это размер блока у которого есть свой адрес (блок называется - машинное слово)

Разрядность программного обеспечения: 32 бита или 64 бита - это означает, что программа содержит команды на машинном уровне исходя из понимания, какой размер машинного слова.

На 64 разрядном компьютере можно запустить программное обеспечение, которое имеет разрядность 32 бита, но оно не будет использовать все возможности, а наоборот нельзя.

*Кодирование целочисленных данных*:
Максимальное число, которое можно записать в 2 байта (от 0 до 15) - это 2^16 - 1
Отрицательные числа в двоичной системе записываются при помощи системы дополнительного кода.
Общая идея системы дополнительного кода: нужно взять значение числа в положительном виде в двоичной системе, все нули и единицы инвертировать (заменить: 0->1 и 1->0) и прибавить единицу.

*Кодирование вещественных чисел*:
Вначале число представляется в нормализованном виде:
345,67 = 0,34567 * 10^3

| знак минус | мантисса | знак экспоненты | экспонента |
| ---------- | -------- | --------------- | ---------- |
| 0          | 34567    | 0               | 3          |

*Подвох*: у вещественных типов данных, кроме диапазона, есть еще одна характеристика - это количество значимых чисел. И если число при переводе в нормализованный вид будет превышать эту характеристику, то символы, которые превышают это количество - будут исключены из расчета.

*Кодирование текстовой информации*:
Каждому символу сопоставляется определенный код (число)

Системы кодирования символов:
- ASCII - 1 символ 1 байт (числа: 0-255); состояла из 2 блоков: 1 блок (0-127) записываются символы английского алфавита и цифры от 0 до 9, а 2 блок (128-255) дополнительный блок, куда записываются символы русского алфавита или какого-то другого. Минус кодировки: можно закодировать только 2 языка;   
- Unicode - 1 символ 2 байта; 1 байт используется для кодирования символа, а другой для кодирования языка. Минус: занимает в 2 раза больше байт;
- UTF-8 - 1 символ 8 бит (1 байт). В системе есть управляющие коды (символы), которые позволяют корректно декодировать символы. Худшая ситуация, когда каждый символ из другого языка. Для хранения данных в программе кодировка неудобна, она используется для передачи данных в интернете, где объем памяти важен.

Кодирование строки сложно тем, что не понятно, сколько байт памяти выделять и когда остановиться.

Подходы для определения окончания строки с переменной длинной:
- Терминальный символ. Когда в конце строки записывается какой-то специальный код, к примеру в конце строки записывается символ: "0", который обозначает, что строка закончилась;
- Без терминального символа. Записывается переменная в которой указана длина строки, для того, чтобы взять и прочитать количество символов;

*Кодирование графической информации*:
Самые первые компьютеры использовали 16 цветов, которые были пронумерованы по порядку.

Модель кодирования цвета: 
- RGB (red-green-blue). Самая популярная модель кодирования цвета;
- CMYK (Cyan-Magenta-Yellow-Key(black)). Часто используется в типографиях;
- HSL (Hue (тон), Saturation (насыщенность) и Lightness (светлота));
- aRGB. Составляющая a (альфа), определяет прозрачность цвета;

Одну и ту же информацию можно хранить по разному, используя различные модели кодирования с учетом их плюсов и минусов.

*Кодирование изображений*:
- Растровое изображение (BMP, JPG, PNG). Хранение осуществляется по пикселям, хранится цвет каждого пикселя. Размер файла зависит от размеров рисунка.
- Векторное изображение. Изображение кодируется с помощью характеристик геометрических примитивов (отрезок, круг, квадрат и т.д.). Картинка представляется, как аппликация. Каждый элемент аппликации математически описывается. Формат не удобен для графических изображений, но удобен для чертежей, схем, логотипов и т.д. Формат легко масштабируется.


# Лекция 6: Язык программирования. Переменная. Тип данных

Состав языка программирования:
- Служебные, зарезервированные слова (keyword);
- Идентификаторы (имена);
- Константные (литеральные) значения. Те значения, которые в программе можно писать;
- Знаки операций. Не обязательно математические;
- Комментарии;

*Комментарий* - любой текст, который компилятором не анализируются, но есть исключения.

Разделяют 2 типа комментариев:
- многострочный комментарий: /* (комментарий) \*/ ; 
- однострочный комментарий: // (комментарий);

Комментарии служат для:
- пояснения к коду;
- для временного исключения кода из программы ("закомментировать" код);

*Переменная* - некоторая часть памяти (некоторое количество байт) с определенным адресом и с определенным способом кодирования информации.

Переменная характеризуется:
- именем;
- типом данных;
- областью видимости;
- временем жизни;
- типом доступа;
- значением (не всегда считается характеристикой, скорее некий атрибут);

*Переменные в C#*:
- Декларация (объявление). В C# необходимо объявлять переменные. Если переменная объявлена в проекте, то она видна везде.
- Инициализация. Запись начального значения в переменную. В C# компилятор не даст прочитать переменную, если ее не инициализировали. Результат инициализации может результатом операции или функции, а можно выполнить стандартным способом (присвоить любое значение);
- Правила задания имени. 
- Имя должно начинаться с буквы или знака подчеркивания "\_";
- Цифры использовать как первый знак - нельзя;
- Имя не должно совпадать со служебным словом. Исключение: если поставить знак: "@", то можно;

*Рекомендации по написанию кода на C# (можно соблюдать или не соблюдать)*:
- Необходимо соблюдать назначение, легкость чтения и понимания;
- Нотацию: Pascal style (пример: GetString) рекомендуется использовать для: типов, методов и глобальных переменных; 
- Нотацию: Camel style (пример: underLine) рекомендуется использовать для всего остального. Если имя составляется из нескольких слов, первая буква в первом слове маленькая, а первые буквы остальных слов, большие; 
- Венгерская нотация с использование префиксов (пример: **i**srtPop). Префиксы - некие обозначения, о которых договорились и они несут некоторую информацию, к примеру, о типе переменной и т.д.; 
- Глаголы использовать только для наименования методов или функций. Переменные не нужно называть глаголами, функции нужно называть глаголами;
- Для сложных объектов, где много элементов, принято давать имя во множественном числе;


C# - это строго типизированный язык. В любой момент времени о каждой переменной, можно сказать, какого она типа. Есть оговорка

Тип данных определяет: 
- Объем выделенной памяти; 
- Множество допустимых значений (диапазон);
- Способ кодирования информации. Обычные целые число или числа с плавающей точкой по разному записываются в памяти; 
- Допустимые операции. Для числовых типов допускаются математические операции, а для строковых не допускаются;
- Местоположение памяти; 
- Базовый тип. В C# все базовые типы имеют свой класс, который можно посмотреть в справочной системе;
- Члены класса. В C# можно посмотреть членов класса, зная, какого типа переменная и через нее можно вызвать определенный метод из класса ассоциированный с этим типом;

Классификация типов данных (не окончательная):
1. Скалярные типы данных. Делятся на: перечисляемые (char, bool и т.д.) или числовые (int и т.д.). Есть переменная и с ней ассоциирована одна ячейка памяти определенного размера;
2. Составные типы данных. Делятся на: регулярные (массивы) и комбинированные (классы, структуры);
3. По организации в памяти. Делятся на: типы по значению (by value) и типы по ссылке (by reference). В переменной, которая относится к типу: by value (по значению) - хранится сама информация. В переменной типа: by reference (ссылочной), к примеру, в  переменной строкового типа, хранится ссылка на область памяти, где хранится текст;

Типы также можно разделить (условно):
- Предопределенные. Заданы изначально в языке (int, bool и т.д.);
- Пользовательские. Можно создавать свои типы или подключать типы, созданные другими программистами; 

В C# числовые типы делятся на знаковые и беззнаковые (имеют букву: "u" вначале, кроме типа: byte)

В C# кроме числовых, есть другие стандартные базовые типы: char (2 байта - 1 символ), string (позволяет хранить текст или строку переменной длины), bool (хранит true или false), DateTime (относится к составным типом, хранит дату и время или либо то, либо то).

В C# используется следующая техника объявления и инициализации переменных:

```C#
// Переменная на отдельной строке
string fileName;
// Объявление нескольких однотипных переменных
uint age, newAge;
// Объявление нескольких разнотипных переменных
bool flag; float price;
// Объявление и инициализация
ushort year = 2016;
```

При записи литеральных значений:
- Чисел в переменные, можно писать числа в двоичной системе, шестнадцатеричной для этого нужно использовать префиксы ("0x" или "0b");
- Символьных в переменные, нужно использовать одинарные кавычки;
- Строковых в переменные, нужно использовать двойные кавычки;

*Примечание*: 
- у вещественных чисел разделитель: "." (точка), когда программа пишется в редакторе, при выводе на экран значения, будет показан тот разделитель, который соответствует региональным настройкам;
- если нужно указать специальные символы (перевод строки, табуляция и т.д.) в тексте, то нужно указать слэш "\\", а если именно в тексте нужно указать специальные символы, то нужно перед строкой поставить знак: "@", тогда строка будет рассматриваться как есть;

Память для переменных выделяется блоками, размер которого определен разрядностью. Для современного компьютера, размер блока 8 байт (64 бита - разрядность).

 К примеру, на переменную с типом: short будет выделено 8 байт, хотя сам тип данных занимает всего 2 байта, а 6 байт будут использованы в пустую.

Зачем объявлять типы данных, которые используют меньше 8 байт, так как остальную память они не используют?! Два основных возражения по данному вопросу:
1. Понимание программы и определенный внутренний контроль. К примеру, для номера сотрудника в компании нет необходимости использовать большие типы данных (назначение переменной);
2. При несовпадении форматов записи, компилятор должен будет конвертировать один формат в другой, на это будет потрачено много времени и задействованы лишние операции. Также компиляторы умеют упаковывать данные. К примеру, в одном массиве несколько значений типа: short, 4 значения будут записаны в одно машинное слово и переданы быстрее;

При выборе конкретного типа, нужно принимать во внимание: назначение переменной и то в каких выражениях она будет использоваться, чтобы минимизировать необходимость конвертации типов данных. 

В C# с некоторой версии разрешены неявно типизированные переменные. Для их инициализации, необходимо использовать слово: var.

При объявлении через var, тип данных никуда не девается, компилятор сам его подбирает.

В первом семестре нельзя использовать var, тип нужно явно указывать.

*Рекомендации по типам данных*:
1. **Необходимо тип указывать явно**;
2. Учитывать назначение переменной (хотите хранить целое объявлять нужно целый тип данных);
3. Меньший объем памяти, лучше большего ();
4. Нессылочный тип, лучше ссылочного в плане быстродействия (если возможно, то от ссылочного типа лучше отказаться);
5. Меньше преобразований (противоречивая рекомендация, противоречит п.3, но ничего абсолютно точного не бывает);
6. Для хранения целочисленных данных, которые будут использоваться для вычислений в большинстве случаев, необходимо, использовать тип: int, для вещественных: double;

*Примечание*: с целочисленными переменными операции выполняются быстрее, иногда ощутимо быстрее, чем с переменными вещественного типа. Можно пойти на хитрость, к примеру, цена товара (маска): "(руб.),(копейки)", вместо вещественного типа, хранить всю цену товара в копейках, и тогда будет тип: int. Но это не всегда сработает, зависит от ситуации, если расчетов много, а пользователю информация показывается несколько раз, то данный способ отличный, но если информация пользователю показывается постоянно и много, то данных подход не стоит реализовывать.


# Лекция 7: Операции

Вывод на экран:

```C#
// Вывод переменной на экран
Console.Writeline(x);
// Вывод переменных по порядковым номерам 2 способа:
Console.Writeline("{0} и {1}", x, y);
Console.Writeline($"{x} и {y}");
```

Для вызова статических членов (статических классов/методов) не нужно создавать какие-либо функции.
Статические члены максимально похожи на обычные классические функции.

В C# знак: "+" имеет двойное значение:
- если плюс указывается с операндами числовых типов, то это обычное сложение;
- если один из операндов строка или оба строки, то это конкатенация (объединение) строк;

Если необходимо ввести символ, которого нет на клавиатуре, то используются специальные конструкции: "\t" (табуляция).

==Операция - символ или последовательность символов, которые обычно не являются самостоятельной инструкцией, указываемой на отдельной строчке. Может быть использована внутри более сложной конструкции, как ее часть. Операция не только ограничивается математическими расчетами.==

==Оператор - самостоятельная конструкция, которая в тексте программы занимает отдельную строку или несколько строчек и заканчивается точкой с запятой.== 

## Приоритет операций
1. Префиксное приращение или уменьшение;
2. Унарные операции;
3. Бинарные мультипликативные (\*, \/, %);
4. Бинарные аддитивные (+, -);
5. Оператор сдвига;
6. Операторы отношения;
7. Операторы равенства;
8. Логические и условные операции;
9. Оператор присваивания (в списке для справки, так как речь про операции, а это оператор);

Как быстро запомнить:
1. Унарные операции;
2. Арифметические операции (по законам математики);
3. Операции отношения: больше, меньше, равно, не равно;
4. Бинарные операции;

**Приоритет операций внутри групп:**

*Математические операции*:
- Unary identity and negation (+, -)
- Multiplication and floating-point division (*, /)
- Modulus arithmetic (%)
- Addition and subtraction (+, -), string concatenation (+)
- Arithmetic bit shift (<<, >>)

*Операции сравнения*:
- All comparison operators (\==, !=, <, <=, >, >=)

*Операции логические*:
- Negation (!)
- Conjunction (&&)
- Inclusive disjunction (||)
- Exclusive disjunction (^)

## Операция инкремента и декремента

- Инкремент - это операция: ++ увеличение на 1 ед. (x++);
- Декремент - это операция: -- уменьшение на 1 ед. (x--);

Операции инкремента и декремента бывают:
- постфиксные (x++/x--) - увеличение происходит после операции;
- префиксные (++x/--x) - увеличение происходит до операции;

## Унарные операции
Унарные операции - это операции, где операнд один;

- Знак числа (+x; -x;);
- Логическое отрицание (!x;);
- Битовое отрицание (~x) - работает, как инверсия битов 0->1 и 1->0;
- Приведение типов ((T)x - Если необходимо переменную преобразовать в другой тип, то слева от нее в скобочках указываем необходимый тип;

## Бинарные арифметические операции:
Бинарные операции - это операции, где операнда 2 и более;

*Бинарные арифметические*:
* "+" (сложение);
* "-" (вычитание);
* "=" (присвоение);
* "\*" (умножение);
* "/" (деление) - результат деления, зависит от того, какого типа операнды указаны в операции деления. Если оба операнда целочисленные, то и результат будет целочисленный, если один операнд вещественный, то и результат будет вещественный;
* "%" (остаток от деления) - остаток от деления может быть дробным;

*Примечание по делению*:
res = x/y

Деление делается в 2 этапа:
- Вначале, вычисляется значение справа от знака: "=" (равно) и результат записывается во временную переменную;
- Затем, значение из временной переменной переписывается в переменную слева от знака: "=" (равно);

## Битовые операции

">> (n) / << (n)" - операции битового сдвига вправо (>>) или влево (<<) на определенное количество бит (n). Применяется для целого типа данных. *Пример*: x >> 2 (сдвиг влево (увеличение) на 2 бита);

Сдвиг на 1 бит влево, равносилен умножению на 2
Сдвиг на 2 бита влево , равносильно умножению на 2^2


*Примечание*: Если сдвинуть биты за пределы границ выделенной памяти для формата, то получится 0

## Операции с типами данных

### Операторы отношения: 
- "<" (меньше);
- ">" (больше);
- "<=" (меньше или равно);
- ">=" (больше или равно);

### Операторы равенства:
- "\==" (равно);
- "!=" (не равно);
- "is" ();

### Логические условные операторы:

- "&" (логическое умножение) - результат операции равен true, когда оба операнда true;
- "|" (логическое сложение) - результат операции равен false, если оба операнда false;
- "^" (исключающее или) - результат операции, если операнды совпадают, то результат false, если нет, то true;
- "&&";
- "||";
- "(n)?(x):(y)";

Разница между двумя знаками ("&&", "||") и одним ("&", "|"): 
1. "&" или "&&" ("|" или "||"): Если у нас операнды логического типа, то использование 2-ух значков против 1-ого, делает работу оператора более умным. К примеру: x&&y, если левый операнд false, то правый не будет вычисляться или к примеру: x||y, если первый операнд true, то второй вычисляться не будет. Данная особенность становится важна, когда правый оператор - это вызов функции.
2. Если операнды числовые, то использование 2-ух значков дает логическую операцию, а использование 1-ого знака дает бинарную операцию: "и", "или";

## Оператор присваивания:

"Добавление сахара" - это добавление таких конструкций языка в язык программирования, которые можно было выразить стандартными средствами по другому, но это делается для удобства;

*Пример*: x+=10 аналогично x = x+10 или x=y=z (множественное присвоение одного значения разным переменным)

Совет: Не нужно писать слишком большие выражения, писать слишком маленькие (мельчить) тоже не нужно, необходима умеренность;

## Модуль (класс) Math

| Функция    | Для чего предназначена                                                                                                                                                                                         |     |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| Abs        | модуль                                                                                                                                                                                                         |     |
| Cos        | косинус                                                                                                                                                                                                        |     |
| Log, Log10 | логарифм                                                                                                                                                                                                       |     |
| Max, Min   | макс и мин                                                                                                                                                                                                     |     |
| Pow        | степень                                                                                                                                                                                                        |     |
| Sign       | знак                                                                                                                                                                                                           |     |
| Sin        | Синус                                                                                                                                                                                                          |     |
| Sqrt       | Извлечение квадратного корня                                                                                                                                                                                   |     |
| Tan        | Тангенс                                                                                                                                                                                                        |     |
| Celling    | округление в большую сторону (4,7 = 5 / -4,7 = 4)                                                                                                                                                              |     |
| Floor      | округление в меньшую сторону, всегда влево (4,7 = 4 / -4,7 = 5)                                                                                                                                                |     |
| Round      | банковское округление (математическое). *Правило для **0,5***: если целая часть четная, то число округляется в меньшую сторону, а если нечетное, то в большую. Т.е. к ближайшему четному. (8,5 = 8 / 9,5 = 10) |     |
| Truncate   | отбрасывание дробной части (4,7 = 4)                                                                                                                                                                           |     |

## Дополнение к операциям сравнения (отношения)

Операции отношения (сравнения) порядка - позволяет для любых двух  значений, выяснить какое значение больше или меньше. На данной операции основываются многие операции и алгоритмы, например, алгоритмы сортировки или поиска.

Не со всеми типами данных определены операции отношения. Для числовых типов они заданы, можно сравнить значения одинакового типа. Для даты определены операции отношения. 

Структуры (похожа на объект) и классы сравнивать нельзя. При сравнении двух структур будет ошибка: "Операция сравнения не задана".

Класс - более сложная реализация структуры. Сравнивать объекты классов тоже нельзя.

Операции отношения со структурами или классами можно реализовать в виде функции сравнения или переопределить самим знаки отношений.

Для сравнения строк в C# есть стандартные функции сравнения: string.Compare(x, y), string.CompareOrdinal(x, y).
Функция: string.CompareOrdinal(x, y) сравнивает строки по кодам символов. Строки хранятся в формате Unicode. Функция берет первый символ первой строки и первой символ второй строки и сравнивает их по таблице Unicode и т.д.

## Конвертация (преобразование) типов данных

Конвертация - это преобразование значения одного типа в другой  (процесс перевода данных из одного (типа) формата в другой). К примеру, нужно подставить переменную с типом: Double, а подставляем переменную с типом Int. 

*Виды конвертации*:
* Конвертацию неявным способом (implicit) делает компилятор и это не будет ошибкой;
* Конвертацию явным способом (explicit) может быть задана в тексте программы;

C# относится к строго типизированным языкам и в случаях, когда конвертация может пойти не по плану, компилятор запретит неявную конвертацию и скомпилировать программу не получится.

- Сужающая конвертация (narrowing) - не всякому типу значения t1 можно сопоставить значение t2. *Пример*: int t1 и short t2;
- Расширяющая конвертация (widening) - любому типу значения t1 можно сопоставить значение t2. *Пример*: short t1 и int t2;

При расширяющей конвертации (widening) допустима неявная конвертация, а при сужающей конвертации (narrowing) компилятор требует, чтобы было написано, что и как преобразуется.


*Способы конвертации*:
* Операция приведения типа данных - в скобках слева от переменной написать необходимый тип. *Пример*: (int) x;
* Преобразование типов с помощью класса System.Convert. *Пример*: Convert.ToInt16(x);
* Преобразование в строку, необходимо делать через: .ToString(). *Пример*: x.ToString(format);
* Преобразование строки в число, необходимо делать через функции: int.Parse() или double.TryParse(). *Пример*: int.Parse(x),  double.TryParse(s, out c)

Технически, при выполнении операции приведении типа, берутся значения из ячеек памяти одной переменной и перекладываются в ячейки памяти другой переменной. При этом, не задействована сложная логика. Если вещественный тип преобразовывать в целый, то дробная часть будет отсечена.

Если необходима более сложная логика, то необходимо использовать класс: System.Convert. К примеру, функции в этом классе используют округление.

При преобразовании типов, не всегда возникает ошибка.
Преобразование из строки в число или из числа в строку, всегда делается только явным образом.

Все, что пользователь вводит в консоли и мы читаем из консоли функцией: Console.Readline(), рассматривается, как число.

Не всякая строка может быть преобразована в число при помощи функции: Parse(). К примеру, стоит не тот знак разделителя или слишком большое число.

**По поводу задач в курсе:** Если не сказано, что должны проверять входные данные, это можно не делать. Т.е. считаем, что входные данные подаются корректные. В задачах, где это указано конкретно, что на вход могут подаваться некорректные данные, то нужно использовать if или TryParse().

Результат операции: "+" (сложения) - это тип int, так как вызывается системная функция, которая возвращает сложение.

Тип данных short можно использовать в задача, где нет математических вычислений. 

Служебное слово: "checked" проверяет вычисления на корректность и перевыполнение и выдает ошибку, если вычисление некорректно. *Пример*:  z = checked((short) (x+y))

*Принцип*: Keep It Simple, Stupid (Делай кратко и просто) – это принцип проектирования, который призывает к простоте, а не к усложнению.

# Советы по выполнениям заданий с автоматической проверкой: 
* Необходимо сделать папку на диске и создать свой каталог, где будут все проекты по C#;
* В Visual Studio указать путь, куда необходимо сохранять проект (в параметрах Visual Studio можно настроить папку по умолчанию);
* Не забывать ставить галочку: "Не использовать операторы верхнего уровня" (при создании проекта в модуле, должны появиться: заголовок: "name space", заголовок класса: "programm" и заголовок класса: "main") иначе на проверку файл не загрузится;
* Вначале пишем код и проводим его отладку в Visual Studio, потом только;
* Перед загрузкой надо закомментировать все строчки, где выдаются информационные сообщения в консоль, поскольку, система точно проверяет соответствие;
* Обязательно пишем в самой верхней строке: "using System";
* Необходимо загружать сам файл, скорее всего его имя: "Program.cs", не нужно копировать в редактор сам код;
* Если случайно загрузили что-то не то, то нужно старый файл удалить, а новый файл загрузить;
* После загрузки файла, нажимаем ссылку протестировать, если результат: 100 из 100, то все хорошо, иначе необходимо развернуть список тестов и посмотреть ошибки и их устранить;
* Если есть ошибки, исправить их необходимо в Visual Studio и повторно проверить, что все работает и перезагрузить файл: "Program.cs";
* Необходимо установить Visual Studio Community Edition, поскольку, кроме написания кода, необходимо будет изучать другие инструменты (инструменты отладки), а они специфичны в разных средах;

# Лекция 8.1: Область видимости и время жизни

**Область видимости (scope)** - это характеристика элемента программы, которая влияет на то в каких пределах (границах) элемент доступен. Характеристика определяет границы доступности. И данная характеристика может быть использована для: переменных, подпрограмм, констант, структур и других элементов, которые можно объявить.

C# объектно-ориентированный язык программирования. Даже самая простая программа написанная на нем, имеет элементы объектно-ориентированного стиля.

Объектно-ориентированный стиль программирования, характерен тем, что имеется дело с объектами, классами и членами классов (свойство, методы, события).

В объектно-ориентированном стиле, есть понятие **уровней доступности (Accessibility Levels)**.

Области видимости зависит от того, где мы объявили переменную и как мы ее объявили. А доступность, это когда на характеристики области видимости, сверху еще накладываются характеристики контейнера, где переменная сидит.

К примеру, в классах можно использовать механизм наследования и поэтому, определенный класс может иметь уровень доступности не конкретно, который у него задан, а который унаследован от родительского класса. Получается взаимовлияние разных объектов.

*Схема процедурного подхода: 
![[Pasted image 20251113152548.png]]

*Комментарии к схеме*: Solution (Решение) может состоять из Project (проектов), Project (проекты) могут состоять из Module (модулей), Module (модули) могут содержать подпрограммы/функции (Sub).

Переменные можно объявлять либо в функции (Sub), либо в модуле (Module), в некоторых языках можно объявлять в проекте (Project).

*Схема подхода .NET (в C#):
![[Pasted image 20251113153328.png]]

*Комментарии к схеме*: Namespace (пространство имен) содержат Class (классы), они вместо Module (модулей). Class (классы) могут содержать подпрограммы/функции (Sub). Есть также  Namespace (пространство имен).
Можно объявлять один Namespace или Class внутри другого, как показано на схеме.
Namespace (пространство имен) - это чисто логическая структура, а не физический файл, как Project (проект). Предназначается для удобной организации кода. Можно в одном проекте сделать несколько Namespace (пространств имен).

Namespace (пространство имен) похоже на библиотеку классов или функций. Одно пространство имен, может объединить 2 проекта. К примеру, разрабатываем Namespace (пространство имен) для математических расчетов или расчетов с матрицами и часть функционала удобнее разрабатывать на C#, а другую на Java. Создаем 2 разных проекта на разных языках, но внутри названия у Namespace (пространство имен) - одинаковые и для внешнего пользователя при обращении к пространству имен не будет заметно на каком языке написана та или иная функция, так как он будет видеть их перечень, а остальное техническая реализация.

Class (класс) в концепции ООП - это не файл, как в старых языках. Файл один, а классов в нем столько, сколько необходимо и они могут быть вложенные.

**По умолчанию будем считать**, что один Project (проект), который состоит из одного Namespace (пространство имен), есть один Class (класс) или несколько, они не вложенные, а в этих класса есть одна или несколько подпрограмм/функций (Sub).

Если класс или его члены статические (со служебным словом: "static"), то это означает, что обратиться к функции Main (например) извне можно через имя класса: Program.Main() используя знак: "." (точку).

Если класс или его члены не статические, то это означает, что обратиться к функции Length (например) извне можно через создание объекта класса (массива).

Директива: "using System" вначале программы обозначает, что если компилятор найдет какое-нибудь незнакомое название, он будет искать в Namespace (пространстве имен): System.

Примечание: В Visual Studio можно по умолчанию указывать, какие Namespace (пространства имен) подключать.

*Проблема затенения имен*:
Иногда бывает, что имена совпадают, и компилятор будет рассматривать ближайший объект, т.е. класс который создал пользователь.
Чтобы избежать таких ошибок, можно использовать: **Global::** System.Console.Writeline(...), при такой директиве, обращение точно будет к тем пространствам имен, которые зарегистрированы в самом языке.

## Области видимости переменных:
Переменные можно объявлять в разных местах:
* Локальные переменные. Это переменные объявленные внутри функции, не требуют указания дополнительных служебных. Видны только в пределах функции;
* Переменная на уровне класса. Может быть объявлена с одним из служебных слов (Access Modifiers): 
	* "public" (публичная/глобальная) - неограниченный доступ. Переменная видна везде в рамках пространства имен и за его пределами;
	* "protected" - класс или типы, производные от этого класса;
	* "internal" - текущая сборка;
	* "protected internal" - класс или типы, производные от этого класса в текущей сборке (protected + internal);
	* "private" - доступна только в одном классе, обратиться извне - нельзя;
* Переменная на уровне блока - если переменная объявлена внутри блока, то она будет видна только в этом блоке;

*Примечание*: В Namespace (пространства имен) переменную объявить нельзя

```C#
namespace ConsoleApplication5
{
    class Program
    {
        public int globalInt;       // глобальная переменная
        private int privateInt;     // закрытая переменная
        static void Main(string[] args)
        {
            int localInt;           // локальная переменная
            localInt = 0;
            if (localInt > 0)
            {
                int localInt2 = 10; // локальная переменная внутри блока
                Console.WriteLine(localInt2);
            }
        }
    }
}
```

Чем меньше область видимости у переменной, тем лучше.

*Причины, почему область видимости переменной нужно стараться сделать меньше*:
1. С меньшей областью видимости, программа становиться более управляемой, т.е. возрастает понимание какие части программы влияют на переменную;
2. Взаимовлияние кода. Если переменная "public", то это значит, что любой класс и любая функция к ней могут обратиться и ее изменить.
3. Глобальные переменные все время висят в памяти;

## Время жизни
Характеристика время жизни, тесно связана с областью видимости.

**Время жизни -** это временной интервал в течение которого, переменная сохраняет за собой одну и ту же область памяти.

Все ссылочные типы данных, ими в программе можно динамически управлять. Их время жизни зависит не только от того, где они объявлены и как, а еще от операторов, которые написаны в коде. В любой момент переменную можно уничтожить или заново создать, если это переменная ссылочного типа (это все объекты).

А время жизни переменных не ссылочного типа (int и т.д.) зависит только от того как и где они были объявлены.

Все локальные переменные живут, пока работает функция. Пока функция не вызвана - переменной просто нет.

Глобальные и закрытые переменные, живут пока работает программа или пока живет объект.

# Лекция 8.2: Константы и перечисления

Константа имеет принципиальное отличие от переменной в том, что при работающей программе ее значение нельзя изменять.

Для значений, которые фиксированы, не нужно писать само значение, а можно указать в тексте символьное обозначение константы. Есть константы, которые уже объявлены в стандартных библиотеках. Пример: Math.Pi, Math.E.

В чем заключается удобство использования констант:
- Читабельность программы;
- Уменьшение вероятности опечатки;
- Централизованное изменение значения;

**Объявление констант:**

Объявление констант очень похоже на объявление переменных. Можно объявлять внутри функции или в классе, можно использовать служебные слова, которые определяют область видимости, так же указывается тип и имя константы.

Отличия от объявления переменных:
- Вначале объявление константы пишется слово: "const";
- У констант обязательна инициализация;
- Справа у констант обязательно должно бить значение, либо литеральное, либо это значение, либо выражение, которое можно вычислить на этапе компиляции.

*Примеры*: 
```C#
const double Pi = 3.1415926;
public const double TaxAllocation = 0.13;
private const string ErrMsg = “Invalid data”;
const int TotalHours = 365*24;
const double DoublePi = Pi * 2;
```

Константы бывают нужны для идентификации определенных ситуаций/событий.
Общепринятая практика, если есть ситуация, когда некий параметр, который может принимать значение из ограниченного набора, принято кодировать числом (пример: номер института).

Для перечисления набора констант в C# можно использовать перечисление: "enum".
Значение этим константам компилятор присваивает следующим образом, самая первая константа будет равна значению: "0", а каждая следующая на единицу больше.
Значения enum можно переопределить, для этого справа пишется равно и чему она равна (пример № 2), исходя из понимания, что это должно быть целое число. 

*Примеры*: 
```C#
enum Days { Sat, Sun, Mon, Tue, Wed, Thu, Fri };
private enum Days: short { Sat, Sun = 0, Mon, 
Tue, Wed, Thu, Fri }
```

Константы нужны не всегда, но если используются фиксированные значения и достаточно много, то удобно использовать константы.

# Лекция 9: Оператор условия. Оператор выбора

## Оператор условия (IF)
**Оператор ветвления** - используется для того, чтобы организовать в алгоритме проверку некоторых условий и ветвление, т.е. выполнение определенных действий, если условие исполняется и если оно не исполняется.

Если ветвлений нет, то такой алгоритм называется последовательный, то такие алгоритмы представляют не очень большой интерес с точки зрения алгоритмизации, т.к. они максимально просты и примитивны.

Ветвление является также основой для оператора цикла, но там оно замаскировано и в явном виде нет оператора: "IF".

В C# оператор: "IF" имеет несколько разновидностей:
* Оператор "IF" (одна ветка), операторы есть только в одном блоке, т.е. выполняется только одна ветвь, только если условие: истинно, а если условие: ложно, то ничего не выполняется или наоборот;
![[Pasted image 20251113202059.png]]

Обозначения на схемах:
* condition (условие) - любое логическое выражение, результат которого: True или False;
* statments (оператор) - их может быть несколько; 

В программировании инверсия решается оператором отрицания: "!"

*Пример*: 
```C#
if (x > 0)
{
pSum += x;
pQuant++;
}

if (x > 0) pQuant++; // если оператор один то можно не писать фигурные скобки
```

 * Оператор "IF" (две ветки), есть условия в двух блоках, т.е. выполняется какая-либо одна ветвь операторов, в зависимости от условия: истинно или ложно;

![[Pasted image 20251113202856.png]]

*Комментарии*: Если есть команды, которые нужно сделать в любом случае, вне зависимости от условия (либо истина, либо ложь), то необходимо их вынести "за скобки" (вынести за оператор: "IF")

*Пример*:
```C#
// если оператор один то можно не писать фигурные скобки
if (gender) // переменные логического типа bool, можно указывать в качетсве условия
strGreeting = "Уважаемый";
else
strGreeting = "Уважаемая";
```

 * Вложенные операторы "IF", выполняется необходимая цепочка операторов, согласно вложенности, в зависимости от условий, которые выполняются;

![[Pasted image 20251113204046.png]]

Возможны 2 случая:
- если нет повторяющихся команд в ветках, то лучше рассмотреть способ с использованием: "else if" (вариант № 2 из примера) и избежать вложенности условия;
- если есть повторяющиеся команды, в ветках, то лучше рассмотреть вариант со вложенным оператором: "IF" (вариант № 1 из примера), чтобы избежать ошибок;

*Примеры* :
```C#
// Пример со светофором. Вариант 1
if (tl == TrafficLight.Green)
// Open
Console.WriteLine("Walk");
else
{
// Close
if (tl == TrafficLight.Yellow)
Console.WriteLine("Wait");
else
Console.WriteLine("Stop");
}

// Пример со светофором. Вариант 2.
TrafficLight tl = TrafficLight.Red;
if (tl == TrafficLight.Green)
// Open
Console.WriteLine("Walk");
else if (tl == TrafficLight.Yellow) // else if может быть сколько угодно
// Close
Console.WriteLine("Wait");
else
// Close
Console.WriteLine("Stop");
```

С переменной типа: "char" доступны такие же операции, которые доступны переменным с типом: "int", поскольку, тип: "char" - хранит код символа.

*Примеры* :
```C#
char chrC = 'A’;
if (chrC >= 'A' && chrC <= 'z')
```


## Оператор выбора (Switсh)

Избыточность есть во всех языках программирования, одну и туже задачу можно решить, как используя оператор ветвления (условия) "IF" или оператор выбора "Switсh".

Если по ходу работы алгоритма, необходимо протестировать некую переменную или выражение на предмет сопоставления с эталонными значениями и необходимо сделать разные действия в соответствии с этими значениями (случаями/кейсами), то лучше использовать оператор: "Switсh".

Если условия более сложные, чем сопоставление, не так строятся условия, переменные разные в условии, если для разных ситуаций нужно общие действия сделать, то лучше использовать оператор: "IF".

В операторе: "Switсh" условия (case) не пересекающиеся, набор команд (statements) в каждом из них, выполняется, только если условие случилось. Если выполняется одно условие (case), то в другое перейти не получится, так устроен оператор: "Switсh".

**Совет для решения задач**: Часто задачу, которая подразумевает некие действия в ответ на определенные совпадения (день недели совпал, то необходимо поставить значения), то такие задачи можно решить и без оператора: "Switсh", но если написано, что задачу нужно решить используя данный оператор, то ее необходимо решать, используя именно указанный оператор.

*Синтаксис*:
```C#
switch (expression)
{
case value1:
	[statements 1];
[case value2:
	statements 2];
...
[default:
	statements n]
}
```

*Примечание*:
* expression - любое корректное выражение, типа: char, string, integral values, enum, bool. Можно указать просто переменную определенного типа, функцию которая возвращает необходимое значение. Объект указать нельзя.;
* case - литеральное обязательное значение, показывает начало конструкции (условия). В блоке обязательно должен быть предусмотрен оператор выхода;
* value - уникальное литеральное значение (используется для сравнения);
* statements - команды;
* default - блок по умолчанию;

*Принцип работы оператора: "Switсh"*:
Выражение (expression) вычисляется один раз, результат записывается во временную область памяти и далее результат сравнивается со значениями (value) условий (case). Если совпадение есть, то выполняются все команды (statements), которые написаны в условии и выход из оператора: "Switсh".
Последний блок, может быть "default" - он срабатывает, если ни один кейс не совпал. Блок: "default" - необязательный, он может быть, а может и не быть.
В блоке: "case" обязательно должен быть предусмотрен оператор выхода:
- break;
- goto case (оператор безусловного перехода);
- return (выход из функции);
- throw (генерация ошибки, выход из функции);

Использование оператора безусловного перехода (goto) - это плохой стиль программирования, так как понять из визуального чтения программы ничего нельзя, требуется глубокий анализ программы в ручном режиме, поскольку, оператор может переходить к разным частям программы. 
Иногда, такой стиль программирования (с излишними операторами: goto) в шутливой  называют: "Спагетти код".

Если в программе очень сложная структура и возникает некоторая форс-мажорная ситуация, тот случай, когда оператор безусловного перехода (goto) будет оправдан.

Играет ли роль расположение условий (case) внутри оператора?! Для пользователя программы - не играет никакой роли расположение блоков условий (case), а играет только для программиста, сопоставление выражения (expression) с значениями условий (case) делается последовательно, а не параллельно.

Оператор: "IF" и оператор: "Switсh" - не являются конкурентами и могут использоваться вместе. К примеру, предварительную проверку входного числа делаем с помощью оператора: "IF", а проверку по необходимым условиям делаем через оператор:  "Switсh"

# Лекция 10: Оператор цикла While

Циклы одна из самых важных тем алгоритмизации и программирования. Циклы есть во всех языках программирования.
В C# - 4 базовых операторов цикла.

Циклы нужны, когда какие-то действия необходимо выполнить многократно.

**Итерация** - это один проход по операторам в цикле, которые нужно многократно выполнять.

*Циклы необходимы*:
- Если количество итераций большое, то оправданно использовать циклы;
- Если количество итераций заранее неизвестно, то необходимо тоже использовать циклы;
- Если количество итераций переменное, то необходимо также использовать циклы;

С циклами нужно легко работать и в них нужно легко ориентироваться.

Чтобы грамотно составить цикл, нужно сделать 3 вещи:
- Определить условие цикла;
- Определить тело цикла;
- Определить тип цикла (в C# - 4 варианта цикла);

## Цикл с предусловием (while)

![[Pasted image 20251117232612.png]]

*while (пер. с англ.)* - пока

*Синтаксис*:
```C#
// Стандартный синтаксис
while (condition)
{
statements;
}

// Можно написать без фигурных скобок, если оператор один
while (condition) statements;
```
*Примечание*:
* condition - условие. Любое выражение, результат которого логического типа (bool), может быть простого или сложное. В цикле условие вычисляется каждый раз;
* statements - тело цикла, выполняемые в цикле операторы (команды);

Логическое условие (condition), должно напрямую или косвенно завесить от тела цикла (statements). Если это не зависит никак, в теле цикла сравнительная переменная не меняется или нет операторов выхода из цикла при определенных условиях, то цикл может выполняться бесконечно.

Из цикла можно выйти, если условие становится: "False" или можно выйти досрочно, используя ряд операторов:
- *Оператор досрочного выхода из цикла*: **break**;
- *Оператор проброса итерации из цикла*: **continue**;

*Примечание*:
- Команда: "break" заставляет выйти за тела цикла, на строчку которая находится за циклом. Команда "break" обычно в цикле указывается совместно с оператором: "IF".
- Команда: "continue", работает следующим образом. Если она выполняется, то оставшийся команды в теле цикла, которые идут ниже данной команды - пропускаются и цикл переходит сразу на первую строку.


## Цикл с постусловием (do while)

![[Pasted image 20251117233926.png]]

*do while (пер. с англ.)* - делай, пока

*Синтаксис*:
```C#
// Стандартный синтаксис
do
{
statements;
} while (condition)
```

Цикл: *do while* работает немного по другому, в отличие от цикла: *while*. В цикле: *do while*  вначале мы заходим и выполняем команды тела цикла, а затем заходим и проверяем условие. Сначала действие, потом проверка условия. 

Какой цикл: *while* или *do while* использовать, зависит от того, сколько итераций в цикле допустимо или возможно. Если задача, где как минимум один раз нужно выполнить тело цикла, то нужно использовать цикл: *do while*, который гарантирует 1 или больше итераций. А вот если количество итераций может быть нуль, то нужно использовать цикл: *while*.


# Лекция 11: Оператор цикла for и foreach
![[Pasted image 20251201221022.png]]


Цикл: *for* оправдан, если количество итераций заранее известно или в процессе работы программы можно вычислить количество итераций.

*Пример* (неоднозначный): Если мы из файла читаем текст посимвольно (знаем в какая кодировка используется), то для чтения текста можем использовать цикл: for. Если, мы читаем файл построчно (мы не знаем сколько строк в файле), то  лучше использовать *while*

Цикл: *for* похож на цикл: while с предусловием

*Синтаксис*:
```C#
// Стандартный синтаксис
for (initializer; condition; iterator)
{
	statements;
}
```

Алгоритм цикла For:
1. Вычисляется секция: initializer. В блоке: initializer обычно задается начальное значение переменной, которая обычно называется: "счетчик цикла";
2. Вычисляется секция condition. Если полученное значение = false, то происходит выход из цикла. Секция: condition, содержит логическое выражение (результат которого: true или false). Примерный формат логического выражения: n<10, где n - счетчик цикла;
3. Выполняются операторы тела цикла, если условия в секции: condition = true;
4. Вычисляется секция: iterator. В данной секции могут быть различные операции, но чаще всего изменение счетчика (увеличение или уменьшение), после каждого шага цикла;
5. Выполняется переход на шаг 2;

***Особенности работы алгоритма цикла: for в C#**:*
В секции: **initializer**:
* Объявление и инициализация переменной;
* Оператор присвоения;
* Вызов метода/функции;
* Постфиксный или префиксный оператор инкремента или декремента;
* Может быть несколько операторов, которые должны отделяться запятой;

В секции: **condition**:
* Любое логическое выражение, которое дает true или false;
* Несколько операторов быть не может;

В секции: **iterator**:
* Обычно изменение счетчика цикла;
* Может быть несколько операторов, которые должны отделяться запятой;
* Может содержать любые операторы;

В секции: **For body (тело цикла)** могут быть операторы:
- break - досрочный выход;
- continue - переход к следующей итерации;
- goto, return, throw - досрочный выход;

Операторов в теле может быть несколько

```C#
// Примеры использования цикла: for 
// Посимвольный вывод на экран строки
string s = "Hello World"
for (int d = 0; d < s.Length; d++)
{
	Console.WriteLine(s[d]);
}

// Пример использования 2-ух операторов в секциях
int d, v;
for (int d = 1, v = 20; d <= v; v--, d++)
{
	Console.WriteLine(v);
}
```

*Примечание*: в C# переменная int и переменная char взаимозаменяемы, можно в переменную int записать char, при этом запишется код символа.

```C#
// Примеры использования цикла: for
// Решение 3 задачи
// Общая идея: запоминать последнюю строку м на основе ее строить следущую

int end  = int.Parse (Console.ReadLine());
string line = "";

for (int c = 1; c <= end; c++)
{
	line = line + c + " "; // добавляем цифру и пробел
	Console.WriteLine(line);
}
```

*Подсказка к заданию с формированием картинки*: Нужно посмотреть на картинку, понять закономерность и вывести некий принцип формирования картинки. Картинка выводится построчно. Когда строка формируется, строка формируется из определенного числа символов и пробелов и нужно увязать количество символов и пробелов с счетчиком строки.

Для формирования строки с необходимым количеством символов, использовать конструкцию:

```C#
string s = new string ('*', 6); // сформируется строка из 6 символов: "*"
```

## Цикл: Foreach

Оригинальный цикл, работает не совсем как остальные циклы, отличается по смыслу, синтаксису.

**Цикл: Foreach** удобен тогда, когда нужно обойти все элементы какого-то множества.

Чтобы сделать что-то с каждым элементом строки или массива, можно использовать **цикл: Foreach**

*Синтаксис*:
```C#
// Стандартный синтаксис
for (int elem in arrItems)
{
	statements;
}
```

*Примечание*:
* ***(int)* elem** - вначале указывается переменная с типом, аналогичным типу, элемента, который находится в множестве;
* **elem** - это ячейка (отдельная в памяти) в которую копируется элемент массива по очереди;

*Особенности работы **цикла: Foreach***:
* Невозможно выборочно взять и обработать элементы, цикл обрабатывает все элементы;
* Границы цикла не установить. Нельзя обойти часть элементов;
* Нельзя влиять на очередность обхода элементов;
* Нельзя изменять элементы множества. Работаем с копией элемента, а не самим массивом;

 *Техническая информация*:

**Цикл: *Foreach*** с любыми множествами, которые внутри себя реализуют интерфейс итератора.

Массив и все примеры множеств элементов - это классы. Класс в любом объектно-ориентированном языке программирования может иметь различные технические характеристики, одна из них - это реализация интерфейсов.

Интерфейс с точки зрения объектно-ориентированного подхода - это возможность работать с объектом через определенную маску (маска не с математической точки зрения), т.е. скрываем реальный объект и обращаемся к нему, как к некоторому другому типу объекта, через маску (это и называется интерфейс). 

Через интерфейс итератора можно обращаться к списку или массиву, так как в интерфейсе задана функция: "дай следующий элемент", при обращении к этой функции, множество дает следующий элемент.

Если есть класс, который является множеством объектов, но он не поддерживает интерфейс итератора (можно узнать в справке), то **цикл: *Foreach*** с ним работать не будет.


# Лекция 12: Подпрограммы (Процедурный подход)

*Парадигма* - это концепция, идея. Она состоит в том, что при формировании программы, используются блоки, формируется структура программы. Не все идет единым списком, можно посмотреть структуру программы, состоящую из блоков, видно начало блока и конец блока, блоки могут быть вложенные, в тексте программы выражается системой отступов - это помогает  легче программу читать разбираться и исправлять.

Парадигма процедурного программирования состоит в том, что мы всю нашу программу, делим на самостоятельные, автономные куски кода, которые называются подпрограммы (процедуры).

## *Процедура (подпрограмма)*
**Процедура (подпрограмма)** - это самостоятельный фрагмент кода, самодостаточный с определенным названием, определенной целью и который эту цель выполняет в любых ситуациях, его работа не зависит от внешних обстоятельств.

Для чего использовать парадигму процедурного программирования: 
* Упрощение анализа решения задач. Если не делать деление на части большой и сложной задачи и писать огромный код, то это чревато всевозможными ошибками; 
* Упрощение управления существующим кодом. Внесение изменений, исправлений, улучшений. В случае когда код состоит из кусочков - это прощен сделать;
* Работа в команде. Деление создания подпрограмм по исполнителям;
* Повторное использование кода;

Язык может считаться процедурным, если в нем есть возможность создания подпрограмм:
- это возможность ее объявить;
- это возможность ее вызвать;
- это возможность передать в нее данные или получить из нее данные;

==В C#, так как он объектно-ориентированный язык, подпрограммы называют методами или функциями. Пока, можно считать это синонимами.==

==C# объектно-ориентированный язык, в котором мы работаем с классами. Все что мы пишем внутри проекта - это функции или методы класса. Чтобы воспользоваться данными функциями (вызвать) в объектно-ориентированной парадигме, необходимо вначале на базе класса создать объект и потом для это объекта вызвать метод.==

==Методы - это некие действия с объектом, они отвечают на вопрос: "Что делать?"==
==Свойства - это все, что характеризует объект: вес, цвет, количество топлива и т.д.==

==*Схема*: Есть класс -> затем объявляем переменную (объект класса) или переменные -> а затем вызываем необходимый метод у переменной через точку (пример: a.drive)==

Для использования процедурного подхода в C#, необходимо использовать служебное слово: "static" при объявлении функции, именно оно позволяет обращаться к функциям без необходимости создавать объект, вызов функции может быть осуществлен при обращении к классу (модулю в старой терминологии).

```C#
// Пример создания статической функции
static void main ()
{
	statments;
}
```


*Работа с функциями состоит из двух частей*:
- Уметь вызвать готовую функцию, написанную ранее;
- Уметь написать свою функцию;

*Чтобы вызвать статическую функцию, нужно написать в коде (синтаксис)*: 
* (название класса).(название функции).

```C#
// Примеры вызова статической функции
Math.Sqrt(dblX);

// Вызов и присвоение переменной
double dblX, dblRes;
dblX = 16;
dblRes = Math.Sqrt(dblX);

// Вызов в операторе
if (Math.Sqrt(dblX) > 4) Console.WriteLine("Done");

// Сочетание с операцией
string strRes = ("Ответ: " + Math.Sqrt(dblX));

// Вложенные функции (одна функция внутри другой)
dblRes = Math.Sqrt(Math.Abs(dblX));

// Вызов и оператор присвоения (не предпочтительный стиль)
if ((dblRes = Math.Sqrt(dblX)) > 4) Console.WriteLine("Done");
```

Есть функции, которые возвращают какой-то результат, т.е. ее вызов может быть замен результатом.

При вызове функции в операторе, вначале вычисляются все функции, затем, результат записывается во временную переменную или переменные, а затем уже вычисляется оператор 

При вложенных функциях, вначале вычисляется самая внутренняя функция, затем результат записывается во временную ячейку памяти, затем эта временная ячейка памяти передается во внешнюю функцию. При этом внешняя функция не знает, откуда появился результат и что в нее вложена еще одна функция, она просто получается результат и работает только с ним. 

Функции, которые ничего не возвращают (return'ом) в выражениях использовать нельзя, например, функции void. Поэтому они должны находится в программе на отдельных строчках.

```C#
// Примеры вызова void функций
Console.Beep();
Console.Writeline(s);
```

## *Аргументы*
Почти всегда работа функции зависит от каких-то внешних факторов. В большинстве случаев, функциям, необходимо передать какие-то сведения на "вход", например, функция: Math.Sqrt("аргумент") должна знать из чего ей извлекать корень.

Передать данные функцию можно через аргумент: 

***Аргументом*** называется и специальная переменная и механизм технический передачи данных.

С точки зрения "готовых" функций, с аргументами нет ничего сложного, необходимо почитать в документации, сколько аргументов у функции, какого они типа и какого они вида.

Пример, у функции: Math.Sqrt() - аргумент один, он типа double и смысл его - это передача числа, корень из которого мы должны извлечь.

Если функции необходимо два и более аргументов, а мы указали один, то это ошибка.

Есть функции перегруженные, когда количество аргументов может быть разным. Есть функции с необязательным числом аргументов. К примеру, функция Math.round (), если ей передать один аргумент, то она округлит до целого, если необходимо округление до 2-ух знаков, то нужно передать второй аргумент или функция Console.WriteLine(), которая может принимать более одного аргумента.

*В качестве аргумента можно указывать*:
- литеральное значение;
- константу;
- переменную;
- выражение;

```C#
// Примеры указания аргументов
double dblX = 16;
dblRes = Math.Sqrt(4); // литеральное значение
const int conValue = 16;
dblRes = Math.Sqrt(conValue); // константа
dblRes = Math.Sqrt(dblX); // переменная
dblRes = Math.Sqrt(dblX + 9); // выражение
dblRes = Math.Sqrt(Math.Abs(dblX - 25)); // вложенные функции
```

## Подключение библиотеки

### *Использование директивы using*

Чтобы к функции обратиться, нужно писать не только название класса, но и пространства имен, но благодаря тому, что используется директива: "using", для вызова функций, писать наименование пространства имен для вызова функции не нужно, к примеру, System.Math.Sqrt, можно просто писать: Math.Sqrt, если указано в директиве: using использование пространства имен System (using System). При компиляции кода, это дает компилятору понять, что можно искать функции из пространства имен которые указаны в директиве: "using".

В последних версиях Visual Studio, директивы "using" можно не указывать явным образом, так как они "зашиты" в настройках проекта, но это фича Visual Studio.

### *Подключение библиотеки*

Пространство имен - это сущность логическая, логическое представление, которое используется разработчиком для обращения к какой-то части кода. Но чтобы это все работало, нужно физически подключить файл (сборку), где эта библиотека находится.

По умолчанию, когда в Visual Studio создается проект на базе шаблона, некоторые библиотеки по умолчанию подключаются сами (к примеру, System и другие).
Если нужно обратиться к какой-то специальной библиотеке, то она может быть не подключена и тогда содержимое этой библиотеки не видно. Вызвать функцию из библиотеки нельзя, если она не подключена, директива: using не сработает и обращение к названию класса и функции тоже работать не будут.

Как подключить библиотеку к проекту в Visual Studio:
- Нажать правой кнопкой мыши (вызвать контекстное меню) на строку: "Зависимости" в обозревателе решений (верхнее правое окно) Project \ Add Reference;
- Нажать левой кнопкой мыши на значение: "Добавить ссылку на модель COM";
- Выбрать необходимую библиотеку из списка;
- Подключить библиотеку;


## Проектирование подпрограммы

С точки зрения математики или синтаксиса нет сложностей, но есть ряд организационных моментов, которые необходимо учитывать.

Функция может быть хорошей или плохой.

Иногда помогает понять, как правильно или неправильно сделана функция - это посмотреть готовую функцию в библиотеке (например: Math), как ее реализовали разработчики.

*Синтаксис для создания функции*:
```C#
// Пример синтаксиса создания функции
(public/private) (static/void) (тип функции) (наименование функции) ((модификатор аргумента) (тип аргумента) (наиемнование аргемента))
{
	statments;
}
```

Хорошая функция, если она сделана правильно. В частности при проектировании функции необходимо ответить на следующие вопросы:
- Цель подпрограммы. Цель должна быть четко сформулирована, она не должна быть слишком аморфной (бесформенной), слишком большой, бессвязной;
	- Плохой пример: Функция выполняет файловые операции;
	- Хороший пример: Функция открывает (закрывает/удаляет) файл;
- Входные/Выходные данные. Предаются чаще всего посредством определенного механизма, чаще всего - это аргументы. Нужно определиться, что подается на вход и что функция отдает на выход вызывающей стороне. Чаще всего, функция проектируется универсальной, это означает, что она должна нормально выполняться, если мы работаем, как в консольном, так и в оконном приложении;
- Алгоритм подпрограммы;
- Тип подпрограммы (процедура, функция). Условное название, связан со следующим пунктом. Нужно определиться, каким способом информация будет подаваться на вход, а каким на выход. На выход информация может подаваться двумя механизмами: 
		1. Использование оператора: "return";
		2. Использование выходных аргументов. Если функции нечего сообщить или не использован механизм: "return", то такая функция называется (объявляется): "void". Это означает, что она ничего не возвращает при помощи механизма: "return". Иногда, такую функцию называют процедура (название условное).
- Количество, тип и механизм передачи данных (аргументов);
- Область видимости и местоположение в проекте. Если проект большой, то это очень важный пункт. Если в решении (solution) несколько проектов, то встает вопрос в каком классе (модуле) объявить функцию и как она будет видна (она будет видна только в этом классе или она будет видна везде);
- Связь с другими подпрограммами или модулями. Если проект большой, то как функция будет взаимодействовать;

```C#
// Пример функции извлечения корня

//Вариант 1
// Извлечение квадратного корня из модуля числа
public static double SafeSqr (double num)
{
	double temp = Math.Abs(num);
	return Math.Sqrt(temp);
}

//Вариант 2
// Функция с выходным аргументом
public static bool SafeSqr2 (double num, out double res)
{
	if (num >= 0)
	{
		res = Math.Sqrt(num);
		return true;
	}
	else
	{
		res = 0;
		return false;
	}
}

//Вариант 3
// Функция с одним и тем же входным и выходным аргументом
public static bool SafeSqr3 (ref double num)
{
	if (num >= 0)
	{
		num = Math.Sqrt(num);
		return true;
	}
	else
		return false;
}
```

*Примечание*: 
- служебное слово: "public" - означает, что функция видна отовсюду в том числе из вне, в том числе за пределами нашей сборки функция тоже будет видна;
- В классическом подходе в C#, функция не может вернуть 2 значения, сейчас уже может, но пока требуется придерживаться классического подхода;
- Обычно, признак успешности выполнения функции возвращается с помощью "return", а все остальное возвращается через выходные аргументы;
- Служебное слово: "out" обозначает, что аргумент выходной. 
- Если не записать значение в выходной аргумент функции, то компилятор выдаст ошибку, значение в любом случае должно быть записано;

*Совет*: Считается плохим тоном, если в результате работы функции, меняются входные аргументы и если это не предусмотрено задачей.


***Техническая реализация***:
Когда вызывается функция, если смотреть на низком уровне, то компилятор уже знает, где в адресном пространстве функция будет находится, то есть он знает ее адрес. Адрес не абсолютный, а относительный, так как конкретно неизвестно в какое место в оперативной памяти будет помещена программа. Известна точка начала памяти, это первая ячейка, где программа находится и нужно сдвинуться на определенное число байт и можно оказаться в первой строке функции, именно сюда и записывается данный сдвиг. 
Но перед вызовом, перед тем, как передать выполнение, сначала идет некоторая обработка аргументов: 
- Если аргумент обычный входной, то в специальную область памяти (стек) записывается копия этого аргумента с которой потом и работает функция и если он в функции изменяется, то это никак не отражается на исходном значении;
- Если аргумент "out", то в этом случае передается не копия элемента, а ссылка на оригинал. И если меняется переменная внутри функции, то и меняется оригинал, т.е. после выполнения функции значение будет измененное;


**Аргументы**:

Модификаторы аргументов:
- None – по значению (входной аргумент);
- Out – выходные (выходной аргумент);
- Ref – по ссылке (входной и выходной);
Отличие выходного аргумента и по ссылке:
- Инициализация фактического аргумента;
- Необходимость задавать значение в функции;

*Комментарий по отличию выходного аргумента и по ссылке*:
Если аргумент: "out", то обязательно необходимо записать в него что-то до выхода из функции, если не записать, то будет ошибка. Инициализировать переменную предназначенную для получения значения из функции - необязательно.
Если аргумент: "ref", то в этот аргумент не обязательно что-то записывать, если в него ничего не записали, то переменная сохранит свое исходное состояние. Обязательно необходимо инициализировать переменную, предназначенную для передачи ее функции, до выполнения самой функции.


**Ссылочные аргументы**
Если тип аргумента ссылочный (ссылка на объект), то можно изменять значения входных переменных, не смотря на то, что это входной аргумент. 
К примеру, передаем в функцию массив (передается ссылка на массив, а не сам массив), то в функции можно изменять значения, которые находятся в самом входящем аргументе (массиве).

Ссылочный тип данных отличается от обычного типа (by value - по значению), что в переменной находится ссылка на ячейку памяти в которой находится объект. 

При вызове функции, делается копия переданной переменной, т.е. в данном контексте (при передаче переменной ссылочного типа в функцию), при работе функции, будет сделана копия переменной, которая содержит ссылку на ячейку памяти, в которой хранится объект.  Поэтому, при вызове функции, если функция подразумевает какие-либо действия с объектом, то изменения отразятся и на вызывающей стороне.

Если использовать не ссылочные типы, а типы по значению (by value), то при работе функции не затрагивается вызывающая сторона, так как функция работает с копией переданного значения.

*Ссылочный тип данных со служебным словом: "ref"*:

Служебное слово: "ref" используется, если необходимо изменить не внутренние данные объекта, а сам объект.

Служебные слова: "ref" и "out" используются со ссылочными типами.

Если необходимо изменить внутреннее наполнение объекта, то не обязательно использовать служебное слово: "ref", а если необходимо изменить сам объект, то служебное слово: "ref" необходимо использовать.

*Что делать, если необходимо, массив передать в функцию, но чтобы изменения элементов массива никак не влияли на оригинал?*

Необходимо сделать физическую копию массива (объекта) используя специальные методы и передать ее в функцию.
Копия объекта создается до момента вызова функции, так как это задача вызывающей стороны, а не самой функции (у массива есть метод: Copy()).


*Комментарии к ссылочному типу: "string"*

Среди всех ссылочных типов (массивы, объекты, переменные созданные на базе класса) есть особый ссылочный тип - это тип: "string".

Если в функции изменять строку, то данные изменения не повлияют на входящую сторону (оригинал), в связи с тем, что любая операция со строкой генерирует новую область памяти с измененными данными.

Если нужно, чтобы переменная со строковым типом данных была изменена в функции, то необходимо использовать служебные слова:  "ref" и "out", как для изменения стандартных типов (by value - по значению).


**Разное и переменное количество аргументов**

* ***Необязательный аргумент (optional)***;

Если необходимо указать в функции необязательный аргумент, то необходимо использовать знак: "=" и какое-либо значение, которое будет использоваться по умолчанию.

Необязательный аргумент можно указывать, либо не указывать при вызове функции. Если он указывается, то какое значение указано в качестве необязательного, такое и будет, а если не указывать ничего, то будет использовано значение по умолчанию.
Необязательный аргументов может быть сколько угодно.

```C#
// Пример необязательного аргумента при создании функции

private static int Remainder (int num, int dig = 2)
{
	return num % dig;
}
```

Особенности указания необязательных аргументов:
* Необязательные аргументы должны указываться в конце списка аргументов и никак иначе, чтобы не возникало двусмысленности;
* Справа от знака равно могут быть указаны значения, которые вычисляются при компиляции: литеральные значения или выражения, которые содержат литеральные значения, константы или знаки операций, другие переменные или функции не допускаются;

Особый случай: Если пользователь не ввел необязательный аргумент, а в нем необходимо отобразить определенное количество действий, которое необходимо совершить, к примеру, пользователь не ввел какое количество дисков нужно проверить и функция должна проверить все диски, которые есть на компьютере.
В таком случае, аргументу должно быть задано такое значение, возможно, не существующее, которое было бы признаком или сигналом, что аргумент не указан и в функции дописать проверку.
Предполагаем, что вызывающая сторона будет использовать здравый смысл и не введет зарезервированное значение.

```C#
// Пример необязательного аргумента с несуществующим значением

private static int Remainder (int num, int dig = -1)
{
	if (dig == -1) 
	{
		statment;
	}
	return num % dig;
}
```

Проблема может возникнуть с необязательными текстовыми аргументами, но нужно всегда отталкиваться от здравого смысла и устанавливать такие значения аргументов по умолчанию, которые пользователь ввести не может, но каждая ситуация индивидуальна.

Необязательные аргументы - это очень полезная особенность.


* ***Переменное количество аргументов***;

Для указания в функции переменного количества аргументов, используется служебное слово: "params".
Служебное слово: "params" обозначает, что в функции будет переменное количество аргументов и все они будут перемещены в одномерный массив.

```C#
// Пример переменного количества аргументов при создании функции

private static int SumABS (params int[] nums)
{
	int sum = 0;
	foreach (int n in nums)
		sum += Math.Abs(n);
	return sum;
}
```

Если не указать ни одного аргумента, то массив будет пустой, если это важно для алгоритма, то это необходимо обязательно предусмотреть.

Служебное слово: "params" означает, что вызывающей стороне просто необходимо передать определенные аргументы и нет необходимости создавать и передавать массив.

Если необходимо назначить формальное значение определенным аргументам, то необходимо использовать следующий синтаксис: 
* (наименование функции) (аргумент_1: (значение), аргумент_2(значение))

```C#
// Пример задания формальных значений аргументам

static void Main ()
{
	Temp (second: 4, first: 8)
}

public static void Temp (int first, int second)
{
	Console.WriteLine (first + " " + second);
}
```


* ***Перегруженные функции***;

```C#
// Пример функции

private static void Swap (ref double first, ref double second )
{
	double temp = first;
	first = second;
	second = temp;
}
```

Функцию: "Swap" можно вызвать, если только переменные имеют тип: "double". Если тип переменных не совпадет, то функция не будет работать. Есть несколько вариантов решения данной проблемы:

1. Можно написать другую функцию Swap, которая будет иметь аргументы другого типа.

```C#
// Пример функции

private static void Swap (ref int first, ref int second )
{
	int temp = first;
	first = second;
	second = temp;
}
```

В проекте C# могут быть функции с одинаковыми названиями, если сигнатура функции не совпадает.

**Сигнатурой функции** - называется первая строка заголовка функции. Также в сигнатуру входят: количество аргументов и тип аргументов. Названия аргументов в сигнатуру не входят.
В сигнатуру, также входит тип возвращаемого значения, но с точки зрения перегруженных функций, тип не относится к сигнатуре.

На этапе компиляции, название функции для компилятора неважно, так как на этапе компиляции, для каждой функции название заменяется на числовой идентификатор и на этапе компиляции компилятор сопоставляет значения и понимает, какую функцию по числовому идентификатору вызвать. 

2. Можно воспользоваться универсальным (generic) методом.


* **Универсальный (generic) метод**;

Термин универсальный (generic) метод используется не только для функций, но и для классов.

Идея универсальных (generic) методов в том, чтобы не объявлять тип данных, а указать его абстрактно, например просто каким-то обозначением. А какой именно тип будет использоваться, будет понятно, когда функция будет уже вызываться. Таким образом, делается позднее определение типа данных на этапе компиляции.

```C#
// Пример функции созданной по универсальному методу

private static void Swap2<T> (ref T first, ref T second )
{
	T temp;
	temp = first;
	first = second;
	second = temp;
}
```

* \<T> - это некоторая абстракция, тип данных, который будет определяться для каждого конкретного вызова компилятором автоматически в зависимости от ситуации;

Можно также указать **несколько типов данных**:
```C#
// Пример функции созданной по универсальному методу с несколькими типами данных

private static void Swap2<T, U> (ref T first, ref U second )
{
	T temp;
	temp = first;
	first = second;
	second = temp;
}
```


**Проблема универсальных методов** заключается в том, что практически любые операции с ними запрещены. Можно присваивать, но складывать, вычитать и т.д. - нельзя.

Можно почитать в справочной документации, как можно ограничить передаваемые типы при использовании универсальных методов и к примеру, передавать только методы по значениям (by value).

Всегда необходимо определять, какой из предложенных методов будет удобнее для вызывающей стороны.

  
*Типовые ошибки при разработке функций*:
1. Нечеткое формулирование цели функции;
2. Невнятное имя функции;
3. Имена аргументов;
4. Указание временных переменных в качестве аргументов;
5. Необходимость вызывающей стороны передавать в качестве; аргументов служебную информацию;
6. Создание "частной" функции;
7. По возможности избегать обращения к глобальным переменным;



**!!!ВАЖНО!!!**
**ТЕПЕРЬ, ПОЧТИ ВСЕ ЗАДАЧИ, НЕОБХОДИМО БУДЕТ ВЫПОЛНЯТЬ В ВИДЕ ОТДЕЛЬНЫХ ФУНКЦИЙ И ТО НА СКОЛЬКО ПРАВИЛЬНО ОФОРМЛЕНЫ ФУНКЦИИ, БУДЕТ ТОЖЕ ОЦЕНИВАТЬСЯ.**



# Лекция 13: Рекурсия

Когда говорим про рекурсию, имеем в виду рекурсивный алгоритм.

**Рекурсивным** называется алгоритм, который в процессе исполнения (выполнения) обращается сам к себе.

Если функция вызывает сама себя - это и есть рекурсия, а сам алгоритм называется рекурсивным.

Рекурсия не обязательно связана с программированием, есть примеры и в рекламных постерах, в живописи, в физике (два зеркала напротив друг друга - бесконечное количество зеркал) и т.д.

Любой рекурсивный алгоритм можно сделать не рекурсивным (итерационным).

**Итерационный алгоритм** - это альтернатива рекурсивному алгоритму, но с помощью циклов. Не бывает таких рекурсивных алгоритмов, где нельзя решить задачу с помощью циклов.

В ряде ситуаций удобнее использовать рекурсивный алгоритм, чем решать задачу с использованием итерационного подхода.

*Принципы рекурсии*:
1. При рекурсивном вызове, рекурсивная функция каждый раз "усекает" задачу до подзадачи;
*Комментарий*: Рекурсивный подход состоит в некотором упрощении задачи, "усечении" имеющейся задачи до подзадачи, которая похожа на оригинальную.
2. И делает это пока полученная на i-том шаге подзадача не окажется настолько тривиальной, что не потребует более рекурсивного вызова;
*Комментарий*: Повторяем действия в п.1 столько раз, сколько требуется, пока, на определенном шаге, не получится ситуация, которую можно решить без функции и алгоритма, дать ответ сразу ничего не вызывая.

*Техническая составляющая*:
Важным для написания рекурсивной функции (рекурсивного алгоритма) являются 2 момента:
1. Рекурсивная зависимость;
2. Условие выхода из рекурсии;

Если эти 2 момента были определены, то можно сказать, что рекурсивная функция написана.

*Типы рекурсии*:
**Прямая рекурсия** - при прямой рекурсии функция вызывает сама себя.

```C#
// Пример прямой рекурсии
static int AAA (int X)
{
	...
	R = AAA(x);
	...
	return ...
}
```

**Косвенная рекурсия** - напрямую вызова функции самой себя не содержит, но содержит этот вызов опосредованно.

```C#
// Пример косвенной рекурсии
static int AAA (int X)
{
	...
	R = BBB(x);
	...
	return ...
}

static int BBB (int X)
{
	...
	R = AAA(x);
	...
	return ...
}
```

На практике, косвенная рекурсия редко используется, так как алгоритмы, где это нужно применять довольно редки. Одна из причин, почему это так - делать отладку таких программ и разбираться, как они работают, чрезвычайно сложно.

```C#
// Пример рекурсивной функции фактириала
static void Main ()
{
	long m = 5;
	long res;
	res = Fact(m);
	Console.WriteLine (res);
}

public static long Fact (long num)
{
	if (num > 1)
		return num * Fact(num - 1);
	else
		return 1;
}
```

*Как происходит вызов функции на низком уровне (с технической стороны)*:

Есть переменная m = 5, вызывается функция: "Fact", в которой есть аргумент: "num", в него будет скопировано число: "5", так как это входной аргумент и это не ссылка.
Проверяется условие (num > 1) и совершается переход на строку ниже, где переменная: "num" умножается на вызов функции: "Fact(num - 1)".
Когда компилятор встречает в тексте программы вызов какой-то функции, то он ставит на паузу дальнейшее исполнение кода и осуществляется переход к функции, которая вызывается (спускается на уровень ниже). Создается дубликат функции: "Fact" со своими локальными переменными и т.д. (похоже на штамповку бланков в типографии). У вызванной функции переменная: "num" будет равна уже значению: "4" и т.д. 
Все этапы будут повторяться пока значение в переменной: "num" не станет равным: "1", тогда функция вернет значение: "1" и пойдет обратный алгоритм, который выйдет на уровень выше в ту функцию которая находится в ожидании получения значения от вызванной функции (все функции вызванные до этого находятся в ожидании получения значения от вызванной функции).

Когда происходит многократный рекурсивный вызов, то все локальные переменные и аргументы запоминаются в специальной области памяти, которая называется **стеком**. Кроме всего прочего, в стеке запоминается точка возврата, так как компилятор должен знать на какой адрес возвращаться, и он дублируется столько раз, сколько рекурсивных вызовов будет. Все это называется **рекурсивный спуск**. 

Количество рекурсивных вызовов называется **глубиной рекурсивного спуска**.

Каждый рекурсивный вызов заставляет дублировать в памяти все локальные переменные и аргументы (аргументы тоже можно отнести к локальным переменным).

Также при каждом рекурсивном вызове выполняются дополнительные действия:
- записать данные в стек;
- вызвать функцию;
- передача аргументов из стека в функцию;
- возврат управления;

Расчет необходимого объема памяти:
* Объем памяти = Память, затрачиваемая на вызов функции * объем рекурсивного спуска;

С рекурсией необходимо быть осторожным, так как памяти может и не хватить и может возникнуть ошибка: переполнение стека: System.StackOvwrflowException.

Стек не бесконечен и обладает своими ограничениями по памяти и посчитать заранее глубину рекурсии до возникновения ошибки теоретически возможно:
- Глубина рекурсии = Выделяемый объем памяти для стека / выделяемый объем памяти для локальной переменной;

Когда идет подъем на уровень выше, то это называется **рекурсивный возврат (подъем)**.

Любую рекурсивную функцию можно переделать в итерационную (цикл), как альтернативный метод. В ряде случаев цикл можно заменить без ухищрений, как например с факториалом, а в ряде случаев, необходимо использовать такие структуры данных, как стек или список.

На практике, никто факториал рассчитывать с помощью рекурсии не будет, так как достаточно высокие расходы по памяти и по времени выполнения алгоритма. Циклом факториал рассчитать быстрее и эффективнее.

Очень часто, чтобы решить задачу рекурсивным способом, нужно немного по другому размышлять.


Последовательность Фиббоначи: 1, 1, 2, 3, 5, 8, 13, 21
*Начиная с 3-его элемента формула последовательности*:  fibonacciSequence = (n-1) + (n - 2)

*Примеры кода реализации последовательности Фиббоначи*:
```C#
static void Main ()
{
	long m = 6;
	long res;
	res = Fib1(m);
	Console.WriteLine (res);
}

// Пример простой рекурсивной функции последовательности Фиббоначи (неоптимальный)
public static ulong Fib1 (ulong num)
{
	if (num > 2)
		return Fib1(num - 1) + Fib1(num - 2);
	else
		return 1;
}

// Пример рекурсивной функции последовательности Фиббоначи с использованием Кэша (массива) (более оптимальный)
private static ulong[] cache = new ulong[100]
public static ulong Fib2 (ulong num)
{
	if (cache[num] > 0)
		return cache[num]
		Fib1(num - 1) + Fib1(num - 2);
	else
		if (num > 2)
			cache[num] = Fib2(num - 1) + Fib2(num - 2);
		else
			cache[num] = 1;
		return cache[num];
}

// Пример рекурсивной функции последовательности Фиббоначи с использованием переменных и цикла (еще более оптимальный)
public static ulong Fib3 (ulong num)
{
	ulong cache1 = 1, cache2 = 1, cache3 = 1;
	for (ulong c = 3; c <= num; c++)
	{
		cache3 = cache1 + cache2;
		cache1 = cache2;
		cache2 = cache3;
	}
	return cache3;
}
// Любопытный вариант (Сокращенное предыдущее решение)
public static ulong Fib4 (ulong num)
{
	ulong cache1 = 1, cache2 = 1;
	for (ulong c = 3; c <= num; c++)
	{
		cache2 = cache1 + cache2;
		cache1 = cache2 - cache1;
	}
	return cache2;
}

// Самое оптимальное решение функции последовательности Фиббоначи без использования циклов и рекурсии с помощью математической формулы
public static ulong Fib5 (ulong num)
{
	double sqrt5 = Math.Sqrt(5);
	double phi = (sqrt5 + 1) / 2
	return (ulong) (Math.Pow(phi, num) / sqrt5 + 0.5);
}
```

В реальном производстве 2 категории критериев по которым программа оценивается:
1. Первая категория (главные критерии):
	- Время (чем меньше времени нужно для достижения результата);
	- Память (чем меньше памяти нужно);
	- Точность расчетов;
2. Вторая категория (дополнительные критерии):
	- Легкость понимания программы;
	- и др. принципы программирования;

Если вычисления происходят один раз, то можно оставить и рекурсивное вычисление, так как выигрыш времени будет несущественный, но если производить вычисления необходимо в цикле много раз для большого объема данных, то выигрыш в 0,1 секунды будет существенный и тогда придется оптимизировать уже говоря о тонкой настройке.

Можно делать оптимизацию не только на алгоритмическом уровне, но и на физическом на уровне того, как команды преобразуются в машинный код.
Иногда, бывает, что используют одни операторы, но не используют другие, потому, что некоторые операторы языка органично ложатся на команды процессора. В процессоре есть команда, которая позволяет это сразу делать, раскладывая команду (действие) на составные части. Если в процессоре операции деления нет, то ему приходится заменять операции деления на другие действия и это все может вырасти в "гармошку", а если операция есть, то процессор может ее выполнить за один такт, тогда необходимо знать какой процессор и что в нем заложено.

*Комментарии к задаче на практике*:
Исходное число 1 и можно ли из него получить число num с помощью операций: "+" прибавить к переменной "а" или "\*" умножить на переменную b.
Если можно, то вывести пользователю последовательность операций, а если нельзя, то пользователю необходимо вывести нельзя.
Как решить задачу:
1. 2 рекурсии;
2. Перевернуть задачу от num выполняя математические операции получить 1;

Если можно вычесть, вычитаем, если нельзя, то заканчиваем.
А вот с делением ситуация следующая, 25 на 4 не делиться, то ветка деления не участвует.
Возможен тупик:
если число делиться на b без остатка (if num%b\==0 ), тогда мы вызываем функцию: F (num/b , a, b)
if res \==1, то мы дошли до нужного значения
А если это не единица? То нужно вычесть "а" и проверить 
Рекурсивный возврат использовать в программе
Первая ветка заводит в тупик.

Строковая переменная, в которую нужно записать действия.


# Требование преподавателя к выполнению практических заданий

## Общие сведения

На примере задачи: "Отрезки в консоли"
- Функция должна возвращать признак true/false;
- Функция не возвращает строковых ошибок;
- Обращать особое внимание на циклы;
- В цикле не должно быть никаких лишних действий, все что можно вынести за цикл, необходимо вынести за цикл.

*Про рекурсию*:
- Рекурсия не всегда нужна, если вы знаете способ решить с помощью цикла, то необходимо решить с помощью цикла.
- Не нужно применять рекурсию, бездумно.


## Требования (что хочет видеть)

 1. Необходимо делать только то, что написано в задании, не нужно писать консольное приложение, если сказано написать метод/функцию;
2. Методы не должны обладать side effect'ами, то есть метод создающий строку не должен ее печатать в консоль.
3. Методы могут возвращать bool, но при этом передавать данные через out, то есть в случае успеха true, неудачи false(см. работу TryParse методов). если успех, то данные вернуться в out переменной
4. Не нужно делать лишней работы в циклах. Например вычислять переменную сто раз
5. Если в конце цикла while есть условие выхода, то логично заменить цикл на do {} while ()
6. Не нужно использовать сущности, которые не можешь объяснить, тип: List и т.д.;
7. Необходимо проверять входные данные, если это имеет смысл

*Примечание*: повторяющиеся значения нужно выносить в переменные, однако, преподаватель не уверен, как лучше делать. Делать их константыми свойствами класса или объявлять в методе.



